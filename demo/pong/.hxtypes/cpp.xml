<haxe>
	<class path="haxe.io.BytesBuffer" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/BytesBuffer.hx">
		<b><t path="haxe.io.BytesData"/></b>
		<addByte public="1" get="inline" set="null" line="55"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="69"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addBytes public="1" get="inline" set="null" line="84"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="106">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>
		Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.
	</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.remoting.AsyncConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/AsyncConnection.hx" interface="1">
		<resolve public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<call public="1" set="method"><f a="params:?result">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></call>
		<setErrorHandler public="1" set="method"><f a="error">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<typedef path="cpp.net.SocketHandle" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/net/Socket.hx" module="cpp.net.Socket"><d/></typedef>
	<class path="cpp.Lib" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/Lib.hx">
		<load public="1" set="method" line="32" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
		Load and return a Cpp primitive from a DLL library.
	</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="44" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
		Tries to load, and always returns a valid function, but the function may throw
		if called.
	</haxe_doc>
		</loadLazy>
		<rethrow public="1" set="method" line="59" static="1"><f a="inExp">
	<d/>
	<e path="Void"/>
</f></rethrow>
		<stringReference public="1" set="method" line="61" static="1"><f a="inExp">
	<d/>
	<e path="Void"/>
</f></stringReference>
		<print public="1" set="method" line="66" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output.
	</haxe_doc>
		</print>
		<haxeToNeko public="1" set="method" line="74" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic
	</haxe_doc>
		</haxeToNeko>
		<nekoToHaxe public="1" set="method" line="82" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic
	</haxe_doc>
		</nekoToHaxe>
		<println public="1" set="method" line="88" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output followed by a newline character.
	</haxe_doc>
		</println>
	</class>
	<class path="cpp.net.Socket" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/net/Socket.hx">
		<newUdpSocket public="1" set="method" line="117" static="1"><f a=""><c path="cpp.net.Socket"/></f></newUdpSocket>
		<select public="1" set="method" line="122" static="1"><f a="read:write:others:timeout">
	<c path="Array"><c path="cpp.net.Socket"/></c>
	<c path="Array"><c path="cpp.net.Socket"/></c>
	<c path="Array"><c path="cpp.net.Socket"/></c>
	<t path="Null"><c path="Float"/></t>
	<a>
		<write><c path="Array"><c path="cpp.net.Socket"/></c></write>
		<read><c path="Array"><c path="cpp.net.Socket"/></c></read>
		<others><c path="Array"><c path="cpp.net.Socket"/></c></others>
	</a>
</f></select>
		<socket_new line="133" static="1"><f a="">
	<e path="Bool"/>
	<t path="Null"><t path="cpp.net.SocketHandle"/></t>
</f></socket_new>
		<socket_close line="134" static="1"><f a="">
	<t path="cpp.net.SocketHandle"/>
	<unknown/>
</f></socket_close>
		<socket_write line="135" static="1"><f a=":">
	<t path="cpp.net.SocketHandle"/>
	<t path="haxe.io.BytesData"/>
	<unknown/>
</f></socket_write>
		<socket_read line="136" static="1"><f a="">
	<t path="cpp.net.SocketHandle"/>
	<t path="haxe.io.BytesData"/>
</f></socket_read>
		<socket_connect line="137" static="1"><f a="::">
	<t path="cpp.net.SocketHandle"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<unknown/>
</f></socket_connect>
		<socket_listen line="138" static="1"><f a=":">
	<t path="cpp.net.SocketHandle"/>
	<c path="Int"/>
	<unknown/>
</f></socket_listen>
		<socket_select line="139" static="1"><f a=":::">
	<c path="Array"><c path="cpp.net.Socket"/></c>
	<c path="Array"><c path="cpp.net.Socket"/></c>
	<c path="Array"><c path="cpp.net.Socket"/></c>
	<t path="Null"><c path="Float"/></t>
	<c path="Array"><c path="Array"><c path="cpp.net.Socket"/></c></c>
</f></socket_select>
		<socket_bind line="140" static="1"><f a="::">
	<t path="cpp.net.SocketHandle"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<unknown/>
</f></socket_bind>
		<socket_accept line="141" static="1"><f a="">
	<t path="cpp.net.SocketHandle"/>
	<t path="Null"><t path="cpp.net.SocketHandle"/></t>
</f></socket_accept>
		<socket_peer line="142" static="1"><f a="">
	<t path="cpp.net.SocketHandle"/>
	<unknown/>
</f></socket_peer>
		<socket_host line="143" static="1"><f a="">
	<t path="cpp.net.SocketHandle"/>
	<unknown/>
</f></socket_host>
		<socket_set_timeout line="144" static="1"><f a=":">
	<t path="cpp.net.SocketHandle"/>
	<c path="Float"/>
	<unknown/>
</f></socket_set_timeout>
		<socket_shutdown line="145" static="1"><f a="::">
	<t path="cpp.net.SocketHandle"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<unknown/>
</f></socket_shutdown>
		<socket_set_blocking line="146" static="1"><f a=":">
	<t path="cpp.net.SocketHandle"/>
	<e path="Bool"/>
	<unknown/>
</f></socket_set_blocking>
		<__s><t path="cpp.net.SocketHandle"/></__s>
		<input public="1" set="null"><c path="cpp.net.SocketInput"/></input>
		<output public="1" set="null"><c path="cpp.net.SocketOutput"/></output>
		<custom public="1"><d/></custom>
		<close public="1" set="method" line="44"><f a=""><e path="Void"/></f></close>
		<read public="1" set="method" line="54"><f a=""><c path="String"/></f></read>
		<write public="1" set="method" line="60"><f a="content">
	<c path="String"/>
	<e path="Void"/>
</f></write>
		<connect public="1" set="method" line="64"><f a="host:port">
	<c path="cpp.net.Host"/>
	<c path="Int"/>
	<e path="Void"/>
</f></connect>
		<listen public="1" set="method" line="75"><f a="connections">
	<c path="Int"/>
	<e path="Void"/>
</f></listen>
		<shutdown public="1" set="method" line="79"><f a="read:write">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></shutdown>
		<bind public="1" set="method" line="83"><f a="host:port">
	<c path="cpp.net.Host"/>
	<c path="Int"/>
	<e path="Void"/>
</f></bind>
		<accept public="1" set="method" line="87"><f a=""><c path="cpp.net.Socket"/></f></accept>
		<peer public="1" set="method" line="91"><f a=""><a>
	<port><c path="Int"/></port>
	<host><c path="cpp.net.Host"/></host>
</a></f></peer>
		<host public="1" set="method" line="98"><f a=""><a>
	<port><c path="Int"/></port>
	<host><c path="cpp.net.Host"/></host>
</a></f></host>
		<setTimeout public="1" set="method" line="105"><f a="timeout">
	<c path="Float"/>
	<e path="Void"/>
</f></setTimeout>
		<waitForRead public="1" set="method" line="109"><f a=""><e path="Void"/></f></waitForRead>
		<setBlocking public="1" set="method" line="113"><f a="b">
	<e path="Bool"/>
	<e path="Void"/>
</f></setBlocking>
		<new public="1" set="method" line="38"><f a="?s">
	<t path="cpp.net.SocketHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.SHA1" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/SHA1.hx">
		<hex_chr line="30" static="1"><c path="String"/></hex_chr>
		<newInt32 get="inline" set="null" line="32" static="1"><f a="left:right">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></newInt32>
		<encode public="1" set="method" line="38" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<hex set="method" line="81" static="1"><f a="num">
	<c path="haxe.Int32"/>
	<c path="String"/>
</f></hex>
		<str2blks_SHA1 set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="haxe.Int32"/></c>
			</f>
			<haxe_doc>
		Convert a string to a sequence of 16-word blocks, stored as an array.
		Append padding bits and the length, as described in the SHA1 standard.
	 </haxe_doc>
		</str2blks_SHA1>
		<add set="method" line="116" static="1">
			<f a="x:y">
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
			</f>
			<haxe_doc>
		Add integers, wrapping at 2^32.
	 </haxe_doc>
		</add>
		<rol set="method" line="125" static="1">
			<f a="num:cnt">
				<c path="haxe.Int32"/>
				<c path="Int"/>
				<c path="haxe.Int32"/>
			</f>
			<haxe_doc>
		Bitwise rotate a 32-bit number to the left
	 </haxe_doc>
		</rol>
		<ft set="method" line="132" static="1">
			<f a="t:b:c:d">
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
			</f>
			<haxe_doc>
		Perform the appropriate triplet combination function for the current iteration
	</haxe_doc>
		</ft>
		<kt set="method" line="142" static="1">
			<f a="t">
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
			</f>
			<haxe_doc>
		Determine the appropriate additive constant for the current iteration
	</haxe_doc>
		</kt>
	</class>
	<class path="cpp.FastIterator" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/FastIterator.hx" extern="1">
		<hasNext public="1" set="method"><f a=""><e path="Bool"/></f></hasNext>
		<next public="1" set="method"><f a=""><c path="cpp.FastIterator.T"/></f></next>
	</class>
	<typedef path="sys.db.SId" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="Int"/>
		<haxe_doc> int with auto increment </haxe_doc>
	</typedef>
	<typedef path="sys.db.SUId" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="Int"/>
		<haxe_doc> int unsigned with auto increment </haxe_doc>
	</typedef>
	<typedef path="sys.db.SBigId" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="Float"/>
		<haxe_doc> big int with auto increment </haxe_doc>
	</typedef>
	<typedef path="sys.db.SInt" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types"><c path="Int"/></typedef>
	<typedef path="sys.db.SUInt" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types"><c path="Int"/></typedef>
	<typedef path="sys.db.SBigInt" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types"><c path="Float"/></typedef>
	<typedef path="sys.db.SSingle" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="Float"/>
		<haxe_doc> single precision float </haxe_doc>
	</typedef>
	<typedef path="sys.db.SFloat" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="Float"/>
		<haxe_doc> double precision float </haxe_doc>
	</typedef>
	<typedef path="sys.db.SBool" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<e path="Bool"/>
		<haxe_doc> use tinyint(1) to distinguish with int </haxe_doc>
	</typedef>
	<typedef path="sys.db.SString" params="Const" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="String"/>
		<haxe_doc> same as varchar(n) </haxe_doc>
	</typedef>
	<typedef path="sys.db.SDate" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="Date"/>
		<haxe_doc> date only, use SDateTime for date+time </haxe_doc>
	</typedef>
	<typedef path="sys.db.SDateTime" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="Date"/>
		<haxe_doc> mysql DateTime </haxe_doc>
	</typedef>
	<typedef path="sys.db.STinyText" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="String"/>
		<haxe_doc> TinyText (up to 255 bytes) </haxe_doc>
	</typedef>
	<typedef path="sys.db.SSmallText" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="String"/>
		<haxe_doc> Text (up to 64KB) </haxe_doc>
	</typedef>
	<typedef path="sys.db.SText" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="String"/>
		<haxe_doc> MediumText (up to 24MB) </haxe_doc>
	</typedef>
	<typedef path="sys.db.SSmallBinary" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="haxe.io.Bytes"/>
		<haxe_doc> Blob type (up to 64KB) </haxe_doc>
	</typedef>
	<typedef path="sys.db.SLongBinary" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="haxe.io.Bytes"/>
		<haxe_doc> LongBlob type (up to 4GB) </haxe_doc>
	</typedef>
	<typedef path="sys.db.SBinary" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="haxe.io.Bytes"/>
		<haxe_doc> MediumBlob type (up to 24MB) </haxe_doc>
	</typedef>
	<typedef path="sys.db.SBytes" params="Const" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="haxe.io.Bytes"/>
		<haxe_doc> same as binary(n) </haxe_doc>
	</typedef>
	<typedef path="sys.db.STinyInt" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="Int"/>
		<haxe_doc> TinyInt [-128...127] </haxe_doc>
	</typedef>
	<typedef path="sys.db.SNull" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="sys.db.SNull.T"/>
		<haxe_doc> specify that this field is nullable </haxe_doc>
	</typedef>
	<typedef path="sys.db.SEncoded" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="Int"/>
		<haxe_doc> specify that the integer use custom encoding </haxe_doc>
	</typedef>
	<typedef path="sys.db.SSerialized" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="String"/>
		<haxe_doc> haxe Serialized string </haxe_doc>
	</typedef>
	<typedef path="sys.db.SNekoSerialized" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types">
		<c path="haxe.io.Bytes"/>
		<haxe_doc> native neko serialized bytes </haxe_doc>
	</typedef>
	<class path="sys.db.SFlags" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Types.hx" module="sys.db.Types" extern="1">
		<ofInt public="1" params="T" get="inline" set="null" line="114" static="1"><f a="i">
	<c path="Int"/>
	<c path="sys.db.SFlags"><c path="ofInt.T"/></c>
</f></ofInt>
		<init public="1" get="inline" set="null" line="102"><f a=""><e path="Void"/></f></init>
		<get public="1" get="inline" set="null" line="105"><f a="v">
	<c path="sys.db.SFlags.T"/>
	<e path="Bool"/>
</f></get>
		<set public="1" get="inline" set="null" line="108"><f a="v">
	<c path="sys.db.SFlags.T"/>
	<e path="Void"/>
</f></set>
		<unset public="1" get="inline" set="null" line="111"><f a="v">
	<c path="sys.db.SFlags.T"/>
	<e path="Void"/>
</f></unset>
		<toInt public="1" get="inline" set="null" line="117"><f a=""><c path="Int"/></f></toInt>
	</class>
	<typedef path="haxe._Http.AbstractSocket" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Http.hx" private="1" module="haxe.Http"><a>
	<write set="method"><f a="str">
	<c path="String"/>
	<e path="Void"/>
</f></write>
	<shutdown set="method"><f a="read:write">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></shutdown>
	<setTimeout set="method"><f a="t">
	<c path="Float"/>
	<e path="Void"/>
</f></setTimeout>
	<output set="null"><c path="haxe.io.Output"/></output>
	<input set="null"><c path="haxe.io.Input"/></input>
	<connect set="method"><f a="host:port">
	<c path="cpp.net.Host"/>
	<c path="Int"/>
	<e path="Void"/>
</f></connect>
	<close set="method"><f a=""><e path="Void"/></f></close>
</a></typedef>
	<class path="haxe.Http" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Http.hx">
		<PROXY public="1" line="69" static="1"><a>
	<port><c path="Int"/></port>
	<host><c path="String"/></host>
	<auth><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></auth>
</a></PROXY>
		<requestUrl public="1" set="method" line="630" static="1"><f a="url">
	<c path="String"/>
	<c path="String"/>
</f></requestUrl>
		<url public="1"><c path="String"/></url>
		<noShutdown public="1"><e path="Bool"/></noShutdown>
		<cnxTimeout public="1"><c path="Float"/></cnxTimeout>
		<responseHeaders public="1"><c path="Hash"><c path="String"/></c></responseHeaders>
		<postData><c path="String"/></postData>
		<chunk_size><t path="Null"><c path="Int"/></t></chunk_size>
		<chunk_buf><c path="haxe.io.Bytes"/></chunk_buf>
		<file><a>
	<size><c path="Int"/></size>
	<param><c path="String"/></param>
	<io><c path="haxe.io.Input"/></io>
	<filename><c path="String"/></filename>
</a></file>
		<headers><c path="Hash"><c path="String"/></c></headers>
		<params><c path="Hash"><c path="String"/></c></params>
		<setHeader public="1" set="method" line="90"><f a="header:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setHeader>
		<setParameter public="1" set="method" line="94"><f a="param:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setParameter>
		<setPostData public="1" set="method" line="99"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></setPostData>
		<request public="1" set="method" line="104"><f a="post">
	<e path="Bool"/>
	<e path="Void"/>
</f></request>
		<fileTransfert public="1" set="method" line="267"><f a="argname:filename:file:size">
	<c path="String"/>
	<c path="String"/>
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></fileTransfert>
		<customRequest public="1" set="method" line="271"><f a="post:api:?sock:?method">
	<e path="Bool"/>
	<c path="haxe.io.Output"/>
	<t path="haxe._Http.AbstractSocket"/>
	<c path="String"/>
	<e path="Void"/>
</f></customRequest>
		<readHttpResponse set="method" line="427"><f a="api:sock">
	<c path="haxe.io.Output"/>
	<t path="haxe._Http.AbstractSocket"/>
	<e path="Void"/>
</f></readHttpResponse>
		<readChunk set="method" line="561"><f a="chunk_re:api:buf:len">
	<c path="EReg"/>
	<c path="haxe.io.Output"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></readChunk>
		<onData public="1" set="dynamic" line="620"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></onData>
		<onError public="1" set="dynamic" line="623"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></onError>
		<onStatus public="1" set="dynamic" line="626"><f a="status">
	<c path="Int"/>
	<e path="Void"/>
</f></onStatus>
		<new public="1" set="method" line="76">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * In PHP Https (SSL) connections are allowed only if the OpenSSL extension is enabled.
	 * @param	url
	 </haxe_doc>
		</new>
	</class>
	<typedef path="haxe.macro.JSGenApi" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/JSGenApi.hx">
		<a>
			<types>
				<c path="Array"><e path="haxe.macro.Type"/></c>
				<haxe_doc> all the types that were compiled by haXe </haxe_doc>
			</types>
			<stackVar set="null">
				<c path="String"/>
				<haxe_doc> the variable used to store the temporary stack in debug mode </haxe_doc>
			</stackVar>
			<setTypeAccessor set="method">
				<f a="callb">
					<f a="">
						<e path="haxe.macro.Type"/>
						<c path="String"/>
					</f>
					<e path="Void"/>
				</f>
				<haxe_doc> define the JS code that gets generated when a class or enum is accessed in a typed expression </haxe_doc>
			</setTypeAccessor>
			<setDebugInfos set="method">
				<f a="c:meth:isStatic">
					<t path="haxe.macro.ClassType"/>
					<c path="String"/>
					<e path="Bool"/>
					<e path="Void"/>
				</f>
				<haxe_doc> set the current class/method for debug stack management </haxe_doc>
			</setDebugInfos>
			<quoteString set="method">
				<f a="s">
					<c path="String"/>
					<c path="String"/>
				</f>
				<haxe_doc> quote and escape the given string constant </haxe_doc>
			</quoteString>
			<outputFile><c path="String"/></outputFile>
			<main>
				<t path="Null"><e path="haxe.macro.TypedExpr"/></t>
				<haxe_doc> the main call expression, if a -main class is defined </haxe_doc>
			</main>
			<isKeyword set="method">
				<f a="ident">
					<c path="String"/>
					<e path="Bool"/>
				</f>
				<haxe_doc> tells if the given identifier is a JS keyword </haxe_doc>
			</isKeyword>
			<generateExpr set="method">
				<f a="e">
					<e path="haxe.macro.TypedExpr"/>
					<c path="String"/>
				</f>
				<haxe_doc> generate the JS code for a given typed expression </haxe_doc>
			</generateExpr>
			<generateConstructor set="method">
				<f a="e">
					<e path="haxe.macro.TypedExpr"/>
					<c path="String"/>
				</f>
				<haxe_doc> generate the JS code for a given class constructor </haxe_doc>
			</generateConstructor>
			<excVar set="null">
				<c path="String"/>
				<haxe_doc> the variable used to store the temporary exception in debug mode </haxe_doc>
			</excVar>
			<buildMetaData set="method">
				<f a="t">
					<t path="haxe.macro.BaseType"/>
					<t path="Null"><e path="haxe.macro.TypedExpr"/></t>
				</f>
				<haxe_doc> create the metadata expression for the given type </haxe_doc>
			</buildMetaData>
		</a>
		<haxe_doc>
	This is the api that is passed to the custom JS generator.
</haxe_doc>
	</typedef>
	<class path="sys.db.Connection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Connection.hx" interface="1">
		<request public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="sys.db.ResultSet"/>
</f></request>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<escape public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></escape>
		<quote public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<addValue public="1" set="method"><f a="s:v">
	<c path="StringBuf"/>
	<d/>
	<e path="Void"/>
</f></addValue>
		<lastInsertId public="1" set="method"><f a=""><c path="Int"/></f></lastInsertId>
		<dbName public="1" set="method"><f a=""><c path="String"/></f></dbName>
		<startTransaction public="1" set="method"><f a=""><e path="Void"/></f></startTransaction>
		<commit public="1" set="method"><f a=""><e path="Void"/></f></commit>
		<rollback public="1" set="method"><f a=""><e path="Void"/></f></rollback>
	</class>
	<typedef path="cpp.FileStat" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/FileSystem.hx" module="cpp.FileSystem"><a>
	<uid><c path="Int"/></uid>
	<size><c path="Int"/></size>
	<rdev><c path="Int"/></rdev>
	<nlink><c path="Int"/></nlink>
	<mtime><c path="Date"/></mtime>
	<mode><c path="Int"/></mode>
	<ino><c path="Int"/></ino>
	<gid><c path="Int"/></gid>
	<dev><c path="Int"/></dev>
	<ctime><c path="Date"/></ctime>
	<atime><c path="Date"/></atime>
</a></typedef>
	<enum path="cpp.FileKind" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/FileSystem.hx" module="cpp.FileSystem">
		<kother a="k"><c path="String"/></kother>
		<kfile/>
		<kdir/>
	</enum>
	<class path="cpp.FileSystem" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/FileSystem.hx">
		<exists public="1" set="method" line="49" static="1"><f a="path">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<rename public="1" set="method" line="53" static="1"><f a="path:newpath">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></rename>
		<stat public="1" set="method" line="58" static="1"><f a="path">
	<c path="String"/>
	<t path="cpp.FileStat"/>
</f></stat>
		<fullPath public="1" set="method" line="68" static="1"><f a="relpath">
	<c path="String"/>
	<c path="String"/>
</f></fullPath>
		<kind public="1" set="method" line="72" static="1"><f a="path">
	<c path="String"/>
	<e path="cpp.FileKind"/>
</f></kind>
		<isDirectory public="1" set="method" line="81" static="1"><f a="path">
	<c path="String"/>
	<e path="Bool"/>
</f></isDirectory>
		<createDirectory public="1" set="method" line="85" static="1"><f a="path">
	<c path="String"/>
	<e path="Void"/>
</f></createDirectory>
		<deleteFile public="1" set="method" line="90" static="1"><f a="path">
	<c path="String"/>
	<e path="Void"/>
</f></deleteFile>
		<deleteDirectory public="1" set="method" line="95" static="1"><f a="path">
	<c path="String"/>
	<e path="Void"/>
</f></deleteDirectory>
		<readDirectory public="1" set="method" line="100" static="1"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></readDirectory>
		<sys_exists line="104" static="1"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></sys_exists>
		<file_delete line="105" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></file_delete>
		<sys_rename line="106" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></sys_rename>
		<sys_stat line="107" static="1"><f a="">
	<c path="String"/>
	<t path="cpp.FileStat"/>
</f></sys_stat>
		<sys_file_type line="108" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></sys_file_type>
		<sys_create_dir line="109" static="1"><f a=":">
	<c path="String"/>
	<c path="Int"/>
	<unknown/>
</f></sys_create_dir>
		<sys_remove_dir line="110" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></sys_remove_dir>
		<sys_read_dir line="111" static="1"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></sys_read_dir>
		<file_full_path line="112" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></file_full_path>
	</class>
	<class path="haxe.remoting.Context" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/Context.hx">
		<share public="1" set="method" line="58" static="1"><f a="name:obj">
	<c path="String"/>
	<a/>
	<c path="haxe.remoting.Context"/>
</f></share>
		<objects><c path="Hash"><a>
	<rec><e path="Bool"/></rec>
	<obj><d/></obj>
</a></c></objects>
		<addObject public="1" set="method" line="35"><f a="name:obj:?recursive">
	<c path="String"/>
	<a/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addObject>
		<call public="1" set="method" line="39"><f a="path:params">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.remoting.ContextAll" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/ContextAll.hx">
		<extends path="haxe.remoting.Context"/>
		<call public="1" set="method" line="29" override="1"><f a="path:params">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="String" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="List" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="80">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="88">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="98">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="193">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="212">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="228">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<typedef path="haxe.web.Config" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/web/Dispatch.hx" module="haxe.web.Dispatch"><a>
	<rules><d/></rules>
	<obj><d/></obj>
</a></typedef>
	<typedef path="haxe.web.Lock" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/web/Dispatch.hx" module="haxe.web.Dispatch"><c path="haxe.web.Lock.T"/></typedef>
	<enum path="haxe.web.MatchRule" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/web/Dispatch.hx" module="haxe.web.Dispatch">
		<MRString/>
		<MRSpod a="c:lock">
			<c path="String"/>
			<e path="Bool"/>
		</MRSpod>
		<MROpt a="r"><e path="haxe.web.MatchRule"/></MROpt>
		<MRInt/>
		<MRFloat/>
		<MRDispatch/>
		<MRBool/>
	</enum>
	<enum path="haxe.web.DispatchRule" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/web/Dispatch.hx" module="haxe.web.Dispatch">
		<DRMult a="r"><c path="Array"><e path="haxe.web.MatchRule"/></c></DRMult>
		<DRMeta a="r"><e path="haxe.web.DispatchRule"/></DRMeta>
		<DRMatch a="r"><e path="haxe.web.MatchRule"/></DRMatch>
		<DRArgs a="r:args:opt">
			<e path="haxe.web.DispatchRule"/>
			<c path="Array"><a>
	<rule><e path="haxe.web.MatchRule"/></rule>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c>
			<e path="Bool"/>
		</DRArgs>
	</enum>
	<enum path="haxe.web.DispatchError" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/web/Dispatch.hx" module="haxe.web.Dispatch">
		<DENotFound a="part"><c path="String"/></DENotFound>
		<DEMissingParam a="p"><c path="String"/></DEMissingParam>
		<DEMissing/>
		<DEInvalidValue/>
	</enum>
	<class path="haxe.web.Dispatch" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/web/Dispatch.hx">
		<GET_RULES static="1"><c path="Array"><c path="Array"><a>
	<rule><e path="haxe.web.MatchRule"/></rule>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c></c></GET_RULES>
		<extractConfig set="method" line="388" static="1"><f a="obj">
	<d/>
	<t path="haxe.web.Config"/>
</f></extractConfig>
		<parts><c path="Array"><c path="String"/></c></parts>
		<params><c path="Hash"><c path="String"/></c></params>
		<name><c path="String"/></name>
		<obj><d/></obj>
		<dispatch public="1" set="method"><f a="obj">
	<a/>
	<e path="Void"/>
</f></dispatch>
		<getParams public="1" set="method"><f a=""><d/></f></getParams>
		<setParams public="1" set="method" line="98"><f a="p">
	<c path="Hash"><c path="String"/></c>
	<e path="Void"/>
</f></setParams>
		<onMeta public="1" set="dynamic" line="102"><f a="v:args">
	<c path="String"/>
	<t path="Null"><c path="Array"><d/></c></t>
	<e path="Void"/>
</f></onMeta>
		<resolveName set="method" line="105"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></resolveName>
		<runtimeDispatch public="1" set="method" line="109"><f a="cfg">
	<t path="haxe.web.Config"/>
	<e path="Void"/>
</f></runtimeDispatch>
		<runtimeGetParams public="1" set="method" line="130"><f a="cfgIndex">
	<c path="Int"/>
	<d/>
</f></runtimeGetParams>
		<match set="method" line="136"><f a="v:r">
	<c path="String"/>
	<e path="haxe.web.MatchRule"/>
	<d/>
</f></match>
		<checkParams set="method" line="175"><f a="params:opt">
	<c path="Array"><a>
	<rule><e path="haxe.web.MatchRule"/></rule>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c>
	<e path="Bool"/>
	<a/>
</f></checkParams>
		<loop set="method" line="189"><f a="args:r">
	<c path="Array"><d/></c>
	<e path="haxe.web.DispatchRule"/>
	<e path="Void"/>
</f></loop>
		<new public="1" set="method" line="72"><f a="url:params">
	<a><split set="null"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split></a>
	<c path="Hash"><c path="String"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Input" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/Input.hx">
		<_float_of_bytes line="266" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_float_of_bytes>
		<_double_of_bytes line="267" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_double_of_bytes>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<readByte public="1" set="method" line="35"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="44"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="65"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="68"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readAll public="1" set="method" line="75"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" set="method" line="96"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<read public="1" set="method" line="104"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" set="method" line="116"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" set="method" line="124"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" set="method" line="141"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="155"><f a=""><c path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="169"><f a=""><c path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="176"><f a=""><c path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="185"><f a=""><c path="Int"/></f></readUInt16>
		<readInt24 public="1" set="method" line="191"><f a=""><c path="Int"/></f></readInt24>
		<readUInt24 public="1" set="method" line="201"><f a=""><c path="Int"/></f></readUInt24>
		<readInt31 public="1" set="method" line="208"><f a=""><c path="Int"/></f></readInt31>
		<readUInt30 public="1" set="method" line="225"><f a=""><c path="Int"/></f></readUInt30>
		<readInt32 public="1" set="method" line="234"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readString public="1" set="method" line="249"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>
	An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.
</haxe_doc>
	</class>
	<class path="cpp.io.FileInput" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<file_eof line="79" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<e path="Bool"/>
</f></file_eof>
		<file_read line="81" static="1"><f a=":::">
	<t path="cpp.io.FileHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_read>
		<file_read_char line="82" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
</f></file_read_char>
		<file_close line="84" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<unknown/>
</f></file_close>
		<file_seek line="85" static="1"><f a="::">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="86" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
</f></file_tell>
		<__f><t path="cpp.io.FileHandle"/></__f>
		<readByte public="1" set="method" line="39" override="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="50" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="61" override="1"><f a=""><e path="Void"/></f></close>
		<seek public="1" set="method" line="66"><f a="p:pos">
	<c path="Int"/>
	<e path="cpp.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<tell public="1" set="method" line="70"><f a=""><c path="Int"/></f></tell>
		<eof public="1" set="method" line="75"><f a=""><e path="Bool"/></f></eof>
		<new public="1" set="method" line="35"><f a="f">
	<t path="cpp.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Use [cpp.io.File.read] to create a [FileInput]
</haxe_doc>
	</class>
	<class path="haxe.Int64" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Int64.hx">
		<make public="1" get="inline" set="null" line="56" static="1"><f a="high:low">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int64"/>
</f></make>
		<ofInt public="1" get="inline" set="null" line="60" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int64"/>
</f></ofInt>
		<ofInt32 public="1" get="inline" set="null" line="64" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="haxe.Int64"/>
</f></ofInt32>
		<toInt public="1" set="method" line="68" static="1"><f a="x">
	<c path="haxe.Int64"/>
	<c path="Int"/>
</f></toInt>
		<getLow public="1" set="method" line="77" static="1"><f a="x">
	<c path="haxe.Int64"/>
	<c path="haxe.Int32"/>
</f></getLow>
		<getHigh public="1" set="method" line="81" static="1"><f a="x">
	<c path="haxe.Int64"/>
	<c path="haxe.Int32"/>
</f></getHigh>
		<add public="1" set="method" line="85" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></add>
		<sub public="1" set="method" line="93" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></sub>
		<mul public="1" set="method" line="101" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></mul>
		<divMod set="method" line="118" static="1"><f a="modulus:divisor">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<a>
		<quotient><c path="haxe.Int64"/></quotient>
		<modulus><c path="haxe.Int64"/></modulus>
	</a>
</f></divMod>
		<div public="1" get="inline" set="null" line="145" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></div>
		<mod public="1" get="inline" set="null" line="153" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></mod>
		<shl public="1" get="inline" set="null" line="161" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="Int"/>
	<c path="haxe.Int64"/>
</f></shl>
		<shr public="1" get="inline" set="null" line="165" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="Int"/>
	<c path="haxe.Int64"/>
</f></shr>
		<ushr public="1" get="inline" set="null" line="169" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="Int"/>
	<c path="haxe.Int64"/>
</f></ushr>
		<and public="1" get="inline" set="null" line="173" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></and>
		<or public="1" get="inline" set="null" line="177" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></or>
		<xor public="1" get="inline" set="null" line="181" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></xor>
		<neg public="1" get="inline" set="null" line="185" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
</f></neg>
		<isNeg public="1" get="inline" set="null" line="193" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<e path="Bool"/>
</f></isNeg>
		<isZero public="1" get="inline" set="null" line="197" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<e path="Bool"/>
</f></isZero>
		<compare public="1" get="inline" set="null" line="201" static="1"><f a="a:b">
	<c path="haxe.Int64"/>
	<c path="haxe.Int64"/>
	<c path="Int"/>
</f></compare>
		<ucompare public="1" get="inline" set="null" line="209" static="1">
			<f a="a:b">
				<c path="haxe.Int64"/>
				<c path="haxe.Int64"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Compare two Int64 in unsigned mode.
	</haxe_doc>
		</ucompare>
		<toStr public="1" get="inline" set="null" line="214" static="1"><f a="a">
	<c path="haxe.Int64"/>
	<c path="String"/>
</f></toStr>
		<high><c path="haxe.Int32"/></high>
		<low><c path="haxe.Int32"/></low>
		<toString set="method" line="38"><f a=""><c path="String"/></f></toString>
		<new set="method" line="33"><f a="high:low">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.macro.Ref" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<toString set="method"><f a=""><c path="String"/></f></toString>
	<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
</a></typedef>
	<enum path="haxe.macro.Type" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx">
		<TType a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.DefType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TType>
		<TMono a="t"><t path="haxe.macro.Ref"><t path="Null"><e path="haxe.macro.Type"/></t></t></TMono>
		<TInst a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TInst>
		<TFun a="args:ret">
			<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c>
			<e path="haxe.macro.Type"/>
		</TFun>
		<TEnum a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.EnumType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TEnum>
		<TDynamic a="t"><t path="Null"><e path="haxe.macro.Type"/></t></TDynamic>
		<TAnonymous a="a"><t path="haxe.macro.Ref"><t path="haxe.macro.AnonType"/></t></TAnonymous>
	</enum>
	<typedef path="haxe.macro.AnonType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a><fields><c path="Array"><t path="haxe.macro.ClassField"/></c></fields></a></typedef>
	<typedef path="haxe.macro.BaseType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
</a></typedef>
	<typedef path="haxe.macro.ClassField" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.FieldKind"/></kind>
	<isPublic><e path="Bool"/></isPublic>
	<expr><t path="Null"><e path="haxe.macro.TypedExpr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.ClassType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<superClass><t path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></t></superClass>
	<statics><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></statics>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isInterface><e path="Bool"/></isInterface>
	<isExtern><e path="Bool"/></isExtern>
	<interfaces><c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c></interfaces>
	<init><t path="Null"><e path="haxe.macro.TypedExpr"/></t></init>
	<fields><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></fields>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<constructor><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></t></constructor>
</a></typedef>
	<typedef path="haxe.macro.EnumField" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<index><c path="Int"/></index>
</a></typedef>
	<typedef path="haxe.macro.EnumType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<names><c path="Array"><c path="String"/></c></names>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<constructs><c path="Hash"><t path="haxe.macro.EnumField"/></c></constructs>
</a></typedef>
	<typedef path="haxe.macro.DefType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
</a></typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<remove set="method"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
	<has set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></has>
	<get set="method"><f a=""><t path="haxe.macro.Metadata"/></f></get>
	<add set="method"><f a="name:params:pos">
	<c path="String"/>
	<c path="Array"><t path="haxe.macro.Expr"/></c>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></add>
</a></typedef>
	<enum path="haxe.macro.FieldKind" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<FVar a="read:write">
			<e path="haxe.macro.VarAccess"/>
			<e path="haxe.macro.VarAccess"/>
		</FVar>
		<FMethod a="k"><e path="haxe.macro.MethodKind"/></FMethod>
	</enum>
	<enum path="haxe.macro.VarAccess" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<AccResolve/>
		<AccRequire a="r"><c path="String"/></AccRequire>
		<AccNormal/>
		<AccNo/>
		<AccNever/>
		<AccInline/>
		<AccCall a="m"><c path="String"/></AccCall>
	</enum>
	<enum path="haxe.macro.MethodKind" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<MethNormal/>
		<MethMacro/>
		<MethInline/>
		<MethDynamic/>
	</enum>
	<enum path="haxe.macro.TypedExpr" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Type.hx" module="haxe.macro.Type"/>
	<class path="cpp.Sys" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/Sys.hx">
		<args public="1" set="method" line="5" static="1"><f a=""><c path="Array"><c path="String"/></c></f></args>
		<getEnv public="1" set="method" line="9" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></getEnv>
		<putEnv public="1" set="method" line="16" static="1"><f a="s:v">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></putEnv>
		<sleep public="1" set="method" line="20" static="1"><f a="seconds">
	<c path="Float"/>
	<e path="Void"/>
</f></sleep>
		<setTimeLocale public="1" set="method" line="24" static="1"><f a="loc">
	<c path="String"/>
	<e path="Bool"/>
</f></setTimeLocale>
		<getCwd public="1" set="method" line="28" static="1"><f a=""><c path="String"/></f></getCwd>
		<setCwd public="1" set="method" line="32" static="1"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></setCwd>
		<systemName public="1" set="method" line="36" static="1"><f a=""><c path="String"/></f></systemName>
		<escapeArgument public="1" set="method" line="40" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" set="method" line="54" static="1"><f a="cmd:?args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="Int"/>
</f></command>
		<exit public="1" set="method" line="63" static="1"><f a="code">
	<c path="Int"/>
	<e path="Void"/>
</f></exit>
		<time public="1" set="method" line="67" static="1"><f a=""><c path="Float"/></f></time>
		<cpuTime public="1" set="method" line="71" static="1"><f a=""><c path="Float"/></f></cpuTime>
		<executablePath public="1" set="method" line="75" static="1"><f a=""><c path="String"/></f></executablePath>
		<environment public="1" set="method" line="79" static="1"><f a=""><c path="Hash"><c path="String"/></c></f></environment>
		<get_env line="91" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></get_env>
		<put_env line="92" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></put_env>
		<_sleep line="93" static="1"><f a="">
	<c path="Float"/>
	<unknown/>
</f></_sleep>
		<set_time_locale line="94" static="1"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></set_time_locale>
		<get_cwd line="95" static="1"><f a=""><c path="String"/></f></get_cwd>
		<set_cwd line="96" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></set_cwd>
		<sys_string line="97" static="1"><f a=""><c path="String"/></f></sys_string>
		<sys_command line="98" static="1"><f a="">
	<c path="String"/>
	<c path="Int"/>
</f></sys_command>
		<sys_exit line="99" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></sys_exit>
		<sys_time line="100" static="1"><f a=""><c path="Float"/></f></sys_time>
		<sys_cpu_time line="101" static="1"><f a=""><c path="Float"/></f></sys_cpu_time>
		<sys_exe_path line="102" static="1"><f a=""><c path="String"/></f></sys_exe_path>
		<sys_env line="103" static="1"><f a=""><c path="Array"><c path="String"/></c></f></sys_env>
	</class>
	<class path="haxe.TimerQueue" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/TimerQueue.hx">
		<delay><c path="Int"/></delay>
		<t><c path="haxe.Timer"/></t>
		<q><c path="Array"><f a=""><e path="Void"/></f></c></q>
		<add public="1" set="method" line="42"><f a="f">
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></add>
		<process set="method" line="50"><f a=""><e path="Void"/></f></process>
		<new public="1" set="method" line="37"><f a="?delay">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Serializer" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="34" static="1">
			<e path="Bool"/>
			<haxe_doc>
		If the values you are serializing can contain
		circular references or objects repetitions, you should
		set USE_CACHE to true to prevent infinite loops.
	</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="40" static="1">
			<e path="Bool"/>
			<haxe_doc>
		Use constructor indexes for enums instead of names.
		This is less reliable but more compact.
	</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="42" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="416" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize a single value and return the string.
	</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="Hash"><c path="Int"/></c></shash>
		<scount><c path="Int"/></scount>
		<useCache public="1"><e path="Bool"/></useCache>
		<useEnumIndex public="1"><e path="Bool"/></useEnumIndex>
		<toString public="1" set="method" line="60"><f a=""><c path="String"/></f></toString>
		<serializeString set="method" line="94"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="113"><f a="v">
	<unknown/>
	<e path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="150"><f a="v">
	<unknown/>
	<e path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="158"><f a="v">
	<d/>
	<e path="Void"/>
</f></serialize>
		<serializeException public="1" set="method" line="397"><f a="e">
	<d/>
	<e path="Void"/>
</f></serializeException>
		<new public="1" set="method" line="51"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.unit.TestStatus" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/unit/TestStatus.hx">
		<done public="1"><e path="Bool"/></done>
		<success public="1"><e path="Bool"/></success>
		<error public="1"><c path="String"/></error>
		<method public="1"><c path="String"/></method>
		<classname public="1"><c path="String"/></classname>
		<posInfos public="1"><t path="haxe.PosInfos"/></posInfos>
		<backtrace public="1"><c path="String"/></backtrace>
		<new public="1" set="method" line="39"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.unit.TestRunner" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/unit/TestRunner.hx">
		<print public="1" set="dynamic" line="38" static="1"><f a="v">
	<d/>
	<e path="Void"/>
</f></print>
		<customTrace set="method" line="79" static="1"><f a="v:?p">
	<unknown/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></customTrace>
		<result><c path="haxe.unit.TestResult"/></result>
		<cases><c path="List"><c path="haxe.unit.TestCase"/></c></cases>
		<add public="1" set="method" line="88"><f a="c">
	<c path="haxe.unit.TestCase"/>
	<e path="Void"/>
</f></add>
		<run public="1" set="method" line="92"><f a=""><e path="Bool"/></f></run>
		<runCase set="method" line="101"><f a="t">
	<c path="haxe.unit.TestCase"/>
	<e path="Void"/>
</f></runCase>
		<new public="1" set="method" line="83"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="cpp.vm.Gc" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/vm/Gc.hx">
		<enable public="1" set="method" line="5" static="1"><f a="inEnable">
	<e path="Bool"/>
	<e path="Void"/>
</f></enable>
		<run public="1" set="method" line="10" static="1"><f a="major">
	<e path="Bool"/>
	<e path="Void"/>
</f></run>
		<trace public="1" set="method" line="15" static="1"><f a="sought:?printInstances">
	<c path="Class"><d/></c>
	<e path="Bool"/>
	<c path="Int"/>
</f></trace>
	</class>
	<class path="haxe.rtti.XmlParser" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/XmlParser.hx">
		<root public="1"><t path="haxe.rtti.TypeRoot"/></root>
		<curplatform><c path="String"/></curplatform>
		<sort public="1" set="method" line="38"><f a="?l">
	<c path="Array"><e path="haxe.rtti.TypeTree"/></c>
	<e path="Void"/>
</f></sort>
		<sortFields set="method" line="64"><f a="fl">
	<t path="Iterable"><t path="haxe.rtti.ClassField"/></t>
	<c path="List"><t path="Null"><t path="haxe.rtti.ClassField"/></t></c>
</f></sortFields>
		<process public="1" set="method" line="84"><f a="x:platform">
	<c path="Xml"/>
	<c path="String"/>
	<e path="Void"/>
</f></process>
		<mergeRights set="method" line="90"><f a="f1:f2">
	<t path="haxe.rtti.ClassField"/>
	<t path="haxe.rtti.ClassField"/>
	<e path="Bool"/>
</f></mergeRights>
		<mergeFields set="method" line="99"><f a="f:f2">
	<t path="haxe.rtti.ClassField"/>
	<t path="haxe.rtti.ClassField"/>
	<e path="Bool"/>
</f></mergeFields>
		<mergeClasses set="method" line="103"><f a="c:c2">
	<t path="haxe.rtti.Classdef"/>
	<t path="haxe.rtti.Classdef"/>
	<e path="Bool"/>
</f></mergeClasses>
		<mergeEnums set="method" line="139"><f a="e:e2">
	<t path="haxe.rtti.Enumdef"/>
	<t path="haxe.rtti.Enumdef"/>
	<e path="Bool"/>
</f></mergeEnums>
		<mergeTypedefs set="method" line="159"><f a="t:t2">
	<t path="haxe.rtti.Typedef"/>
	<t path="haxe.rtti.Typedef"/>
	<e path="Bool"/>
</f></mergeTypedefs>
		<merge set="method" line="167"><f a="t">
	<e path="haxe.rtti.TypeTree"/>
	<e path="Void"/>
</f></merge>
		<mkPath set="method" line="242"><f a="p">
	<c path="String"/>
	<t path="haxe.rtti.Path"/>
</f></mkPath>
		<mkTypeParams set="method" line="246"><f a="p">
	<c path="String"/>
	<t path="haxe.rtti.TypeParams"/>
</f></mkTypeParams>
		<mkRights set="method" line="253"><f a="r">
	<c path="String"/>
	<e path="haxe.rtti.Rights"/>
</f></mkRights>
		<xerror set="method" line="263"><f a="c">
	<c path="haxe.xml.Fast"/>
	<d/>
</f></xerror>
		<xroot set="method" line="267"><f a="x">
	<c path="haxe.xml.Fast"/>
	<e path="Void"/>
</f></xroot>
		<processElement public="1" set="method" line="273"><f a="x">
	<c path="Xml"/>
	<e path="haxe.rtti.TypeTree"/>
</f></processElement>
		<xpath set="method" line="283"><f a="x">
	<c path="haxe.xml.Fast"/>
	<t path="haxe.rtti.PathParams"/>
</f></xpath>
		<xclass set="method" line="294"><f a="x">
	<c path="haxe.xml.Fast"/>
	<t path="haxe.rtti.Classdef"/>
</f></xclass>
		<xclassfield set="method" line="330"><f a="x">
	<c path="haxe.xml.Fast"/>
	<t path="haxe.rtti.ClassField"/>
</f></xclassfield>
		<xenum set="method" line="352"><f a="x">
	<c path="haxe.xml.Fast"/>
	<t path="haxe.rtti.Enumdef"/>
</f></xenum>
		<xenumfield set="method" line="372"><f a="x">
	<c path="haxe.xml.Fast"/>
	<t path="haxe.rtti.EnumField"/>
</f></xenumfield>
		<xtypedef set="method" line="400"><f a="x">
	<c path="haxe.xml.Fast"/>
	<t path="haxe.rtti.Typedef"/>
</f></xtypedef>
		<xtype set="method" line="423"><f a="x">
	<c path="haxe.xml.Fast"/>
	<e path="haxe.rtti.CType"/>
</f></xtype>
		<xtypeparams set="method" line="474"><f a="x">
	<c path="haxe.xml.Fast"/>
	<c path="List"><e path="haxe.rtti.CType"/></c>
</f></xtypeparams>
		<defplat set="method" line="481"><f a=""><c path="List"><c path="String"/></c></f></defplat>
		<new public="1" set="method" line="34"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.remoting.Connection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/Connection.hx" interface="1">
		<resolve public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.Connection"/>
</f></resolve>
		<call public="1" set="method"><f a="params">
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<haxe_dynamic><c path="haxe.remoting.Connection"/></haxe_dynamic>
	</class>
	<class path="haxe.remoting.HttpConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/HttpConnection.hx">
		<implements path="haxe.remoting.Connection"/>
		<TIMEOUT public="1" line="29" static="1"><c path="Int"/></TIMEOUT>
		<processRequest public="1" set="method" line="97" static="1"><f a="requestData:ctx">
	<c path="String"/>
	<c path="haxe.remoting.Context"/>
	<c path="String"/>
</f></processRequest>
		<__url><c path="String"/></__url>
		<__path><c path="Array"><c path="String"/></c></__path>
		<resolve public="1" set="method" line="39"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.Connection"/>
</f></resolve>
		<call public="1" set="method" line="45"><f a="params">
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<new set="method" line="34"><f a="url:path">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.remoting.Connection"/></haxe_dynamic>
	</class>
	<class path="cpp.vm.Deque" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/vm/Deque.hx">
		<q><d/></q>
		<add public="1" set="method" line="33"><f a="i">
	<c path="cpp.vm.Deque.T"/>
	<e path="Void"/>
</f></add>
		<push public="1" set="method" line="36"><f a="i">
	<c path="cpp.vm.Deque.T"/>
	<e path="Void"/>
</f></push>
		<pop public="1" set="method" line="39"><f a="block">
	<e path="Bool"/>
	<c path="cpp.vm.Deque.T"/>
</f></pop>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.BaseCode" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/BaseCode.hx">
		<encode public="1" set="method" line="127" static="1"><f a="s:base">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<decode public="1" set="method" line="132" static="1"><f a="s:base">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></decode>
		<base><c path="haxe.io.Bytes"/></base>
		<nbits><c path="Int"/></nbits>
		<tbl><c path="Array"><c path="Int"/></c></tbl>
		<encodeBytes public="1" set="method" line="44"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></encodeBytes>
		<initTable set="method" line="72"><f a=""><e path="Void"/></f></initTable>
		<decodeBytes public="1" set="method" line="81"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decodeBytes>
		<encodeString public="1" set="method" line="111"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encodeString>
		<decodeString public="1" set="method" line="119"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></decodeString>
		<new public="1" set="method" line="33"><f a="base">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="sys.db.Transaction" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Transaction.hx">
		<isDeadlock public="1" set="method" line="29" static="1"><f a="e">
	<d/>
	<e path="Bool"/>
</f></isDeadlock>
		<runMainLoop set="method" line="33" static="1"><f a="mainFun:logError:count">
	<f a=""><e path="Void"/></f>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<c path="Int"/>
	<e path="Void"/>
</f></runMainLoop>
		<main public="1" set="method" line="56" static="1"><f a="cnx:mainFun:logError">
	<c path="sys.db.Connection"/>
	<f a=""><e path="Void"/></f>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></main>
	</class>
	<class path="sys.db.ResultSet" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/ResultSet.hx" interface="1">
		<length public="1" get="getLength" set="null"><c path="Int"/></length>
		<nfields public="1" get="getNFields" set="null"><c path="Int"/></nfields>
		<hasNext public="1" set="method"><f a=""><e path="Bool"/></f></hasNext>
		<next public="1" set="method"><f a=""><d/></f></next>
		<results public="1" set="method"><f a=""><c path="List"><d/></c></f></results>
		<getResult public="1" set="method"><f a="n">
	<c path="Int"/>
	<c path="String"/>
</f></getResult>
		<getIntResult public="1" set="method"><f a="n">
	<c path="Int"/>
	<c path="Int"/>
</f></getIntResult>
		<getFloatResult public="1" set="method"><f a="n">
	<c path="Int"/>
	<c path="Float"/>
</f></getFloatResult>
		<getFieldsNames public="1" set="method"><f a=""><t path="Null"><c path="Array"><c path="String"/></c></t></f></getFieldsNames>
	</class>
	<class path="sys.db.Object" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Object.hx">
		<_locked set="null"><e path="Bool"/></_locked>
		<_manager set="null"><c path="sys.db.Manager"><d/></c></_manager>
		<insert public="1" set="method" line="43"><f a=""><e path="Void"/></f></insert>
		<update public="1" set="method" line="47"><f a=""><e path="Void"/></f></update>
		<lock public="1" set="method" line="51"><f a=""><e path="Void"/></f></lock>
		<delete public="1" set="method" line="55"><f a=""><e path="Void"/></f></delete>
		<toString public="1" set="method" line="59"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="37"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	SPOD Object : the persistent object base type. See the tutorial on haXe
	website to learn how to use SPOD.
</haxe_doc>
	</class>
	<class path="haxe.io.BytesInput" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><c path="Int"/></pos>
		<len><c path="Int"/></len>
		<readByte public="1" set="method" line="56" override="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="75" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="35"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.remoting.SyncSocketConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/SyncSocketConnection.hx">
		<implements path="haxe.remoting.Connection"/>
		<create public="1" set="method" line="82" static="1"><f a="s:?ctx">
	<t path="haxe.remoting.Socket"/>
	<c path="haxe.remoting.Context"/>
	<c path="haxe.remoting.SyncSocketConnection"/>
</f></create>
		<__path><c path="Array"><c path="String"/></c></__path>
		<__proto><c path="haxe.remoting.SocketProtocol"/></__proto>
		<resolve public="1" set="method" line="38"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.Connection"/>
</f></resolve>
		<call public="1" set="method" line="44"><f a="params">
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<processRequest public="1" set="method" line="60"><f a=""><e path="Void"/></f></processRequest>
		<onRequestError public="1" set="method" line="67"><f a="path:args:exc">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
	<e path="Void"/>
</f></onRequestError>
		<setProtocol public="1" set="method" line="70"><f a="p">
	<c path="haxe.remoting.SocketProtocol"/>
	<e path="Void"/>
</f></setProtocol>
		<getProtocol public="1" set="method" line="74"><f a=""><c path="haxe.remoting.SocketProtocol"/></f></getProtocol>
		<close public="1" set="method" line="78"><f a=""><e path="Void"/></f></close>
		<new set="method" line="33"><f a="proto:path">
	<c path="haxe.remoting.SocketProtocol"/>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.remoting.Connection"/></haxe_dynamic>
	</class>
	<class path="cpp.rtti.FieldIntegerLookup" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/rtti/FieldIntegerLookup.hx" interface="1"><haxe_doc>
	If you implement this interface, then the backend will generate code that
	allows fast dynamic access to fields by integer id.  This should speed up the CFFI.
</haxe_doc></class>
	<class path="cpp.zip.Uncompress" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/zip/Uncompress.hx">
		<run public="1" set="method" line="46" static="1"><f a="src:?bufsize">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_inflate_init line="64" static="1"><f a="">
	<t path="Null"><c path="Int"/></t>
	<unknown/>
</f></_inflate_init>
		<_inflate_buffer line="65" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<a>
		<write><c path="Int"/></write>
		<read><c path="Int"/></read>
		<done><e path="Bool"/></done>
	</a>
</f></_inflate_buffer>
		<_inflate_end line="66" static="1"><f a="">
	<d/>
	<unknown/>
</f></_inflate_end>
		<_set_flush_mode line="67" static="1"><f a=":">
	<d/>
	<unknown/>
	<unknown/>
</f></_set_flush_mode>
		<s><d/></s>
		<this_run public="1" set="method" line="34"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<a>
		<write><c path="Int"/></write>
		<read><c path="Int"/></read>
		<done><e path="Bool"/></done>
	</a>
</f></this_run>
		<setFlushMode public="1" set="method" line="38"><f a="f">
	<e path="cpp.zip.Flush"/>
	<e path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="42"><f a=""><e path="Void"/></f></close>
		<new public="1" set="method" line="30"><f a="windowBits">
	<t path="Null"><c path="Int"/></t>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Eof" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/Eof.hx">
		<toString set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	This exception is raised when reading while data is no longer available in the [Input].
</haxe_doc>
	</class>
	<class path="Class" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="Reflect" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/Reflect.hx">
		<hasField public="1" set="method" line="29" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" set="method" line="33" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" set="method" line="42" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="49" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="56" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="60" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="64" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="72" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="79" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="84" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="95" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="cpp.Utf8" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/Utf8.hx">
		<encode public="1" set="method" line="23" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<decode public="1" set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></decode>
		<iter public="1" set="method" line="33" static="1"><f a="s:chars">
	<c path="String"/>
	<f a="">
		<c path="Int"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></iter>
		<charCodeAt public="1" set="method" line="39" static="1"><f a="s:index">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
</f></charCodeAt>
		<validate public="1" set="method" line="44" static="1"><f a="s">
	<c path="String"/>
	<e path="Bool"/>
</f></validate>
		<length public="1" set="method" line="52" static="1"><f a="s">
	<c path="String"/>
	<c path="Int"/>
</f></length>
		<compare public="1" set="method" line="57" static="1"><f a="a:b">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
</f></compare>
		<sub public="1" set="method" line="69" static="1"><f a="s:pos:len">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></sub>
		<__s><c path="Array"><c path="Int"/></c></__s>
		<addChar public="1" set="method" line="13"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></addChar>
		<toString public="1" set="method" line="17"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="7"><f a="?size">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="haxe.StackItem" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Stack.hx" module="haxe.Stack">
		<Module a="m"><c path="String"/></Module>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<Lambda a="v"><c path="Int"/></Lambda>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<c path="Int"/>
		</FilePos>
		<CFunction/>
		<haxe_doc>
	Elements return by [Stack] methods.
</haxe_doc>
	</enum>
	<class path="haxe.Stack" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Stack.hx">
		<callStack public="1" set="method" line="46" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the call stack elements.
	</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="69" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		catched.
	</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="100" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of the stack as a printable string.
	</haxe_doc>
		</toString>
		<itemToString set="method" line="109" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<e path="Void"/>
</f></itemToString>
		<makeStack set="method" line="135" static="1"><f a="s">
	<unknown/>
	<unknown/>
</f></makeStack>
		<haxe_doc>
	Get informations about the call stack.
</haxe_doc>
	</class>
	<class path="IntIter" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="haxe.FastCell" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/FastList.hx" module="haxe.FastList">
		<elt public="1"><c path="haxe.FastCell.T"/></elt>
		<next public="1"><c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c></next>
		<new public="1" set="method" line="30"><f a="elt:next">
	<c path="haxe.FastCell.T"/>
	<c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastListIterator" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/FastList.hx" module="haxe.FastList">
		<extends path="cpp.FastIterator"><c path="haxe.FastListIterator.T"/></extends>
		<current public="1"><c path="haxe.FastCell"><c path="haxe.FastListIterator.T"/></c></current>
		<hasNext public="1" set="method" line="36" override="1"><f a=""><e path="Bool"/></f></hasNext>
		<next public="1" set="method" line="37" override="1"><f a=""><c path="haxe.FastListIterator.T"/></f></next>
		<new public="1" set="method" line="39"><f a="head">
	<c path="haxe.FastCell"><c path="haxe.FastListIterator.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastList" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/FastList.hx">
		<head public="1"><c path="haxe.FastCell"><c path="haxe.FastList.T"/></c></head>
		<add public="1" get="inline" set="null" line="60">
			<f a="item">
				<c path="haxe.FastList.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the head of the list.
	</haxe_doc>
		</add>
		<first public="1" get="inline" set="null" line="68">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<pop public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" get="inline" set="null" line="90">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<remove public="1" set="method" line="98">
			<f a="v">
				<c path="haxe.FastList.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="116"><f a=""><t path="Iterator"><c path="haxe.FastList.T"/></t></f></iterator>
		<toString public="1" set="method" line="141">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="54">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. A different class is created for each container used in platforms where it matters
</haxe_doc>
	</class>
	<enum path="haxe.xml.Filter" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Check.hx" module="haxe.xml.Check">
		<FReg a="matcher"><c path="EReg"/></FReg>
		<FInt/>
		<FEnum a="values"><c path="Array"><c path="String"/></c></FEnum>
		<FBool/>
	</enum>
	<enum path="haxe.xml.Attrib" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Check.hx" module="haxe.xml.Check"><Att a="name:?filter:?defvalue">
	<c path="String"/>
	<e path="haxe.xml.Filter"/>
	<c path="String"/>
</Att></enum>
	<enum path="haxe.xml.Rule" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Check.hx" module="haxe.xml.Check">
		<ROptional a="rule"><e path="haxe.xml.Rule"/></ROptional>
		<RNode a="name:?attribs:?childs">
			<c path="String"/>
			<c path="Array"><e path="haxe.xml.Attrib"/></c>
			<e path="haxe.xml.Rule"/>
		</RNode>
		<RMulti a="rule:?atLeastOne">
			<e path="haxe.xml.Rule"/>
			<e path="Bool"/>
		</RMulti>
		<RList a="rules:?ordered">
			<c path="Array"><e path="haxe.xml.Rule"/></c>
			<e path="Bool"/>
		</RList>
		<RData a="?filter"><e path="haxe.xml.Filter"/></RData>
		<RChoice a="choices"><c path="Array"><e path="haxe.xml.Rule"/></c></RChoice>
	</enum>
	<enum path="haxe.xml._Check.CheckResult" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Check.hx" private="1" module="haxe.xml.Check">
		<CMissingAttrib a="att:x">
			<c path="String"/>
			<c path="Xml"/>
		</CMissingAttrib>
		<CMissing a="r"><e path="haxe.xml.Rule"/></CMissing>
		<CMatch/>
		<CInvalidData a="x:f">
			<c path="Xml"/>
			<e path="haxe.xml.Filter"/>
		</CInvalidData>
		<CInvalidAttrib a="att:x:f">
			<c path="String"/>
			<c path="Xml"/>
			<e path="haxe.xml.Filter"/>
		</CInvalidAttrib>
		<CInElement a="x:r">
			<c path="Xml"/>
			<e path="haxe.xml._Check.CheckResult"/>
		</CInElement>
		<CExtraAttrib a="att:x">
			<c path="String"/>
			<c path="Xml"/>
		</CExtraAttrib>
		<CExtra a="x"><c path="Xml"/></CExtra>
		<CElementExpected a="name:x">
			<c path="String"/>
			<c path="Xml"/>
		</CElementExpected>
		<CDataExpected a="x"><c path="Xml"/></CDataExpected>
	</enum>
	<class path="EReg" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/EReg.hx">
		<regexp_new_options line="157" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></regexp_new_options>
		<regexp_match line="158" static="1"><f a=":::">
	<d/>
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<d/>
</f></regexp_match>
		<regexp_matched line="159" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<d/>
</f></regexp_matched>
		<regexp_matched_pos line="160" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<a>
		<pos><c path="Int"/></pos>
		<len><c path="Int"/></len>
	</a>
</f></regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><e path="Bool"/></global>
		<match public="1" set="method" line="40">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" set="method" line="49">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="54">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="59">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="65">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" set="method" line="69">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" set="method" line="93">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" set="method" line="144">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" set="method" line="32"><f a="r:opt">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="haxe.xml.Check" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Check.hx">
		<blanks line="62" static="1"><c path="EReg"/></blanks>
		<isBlank set="method" line="64" static="1"><f a="x">
	<c path="Xml"/>
	<e path="Bool"/>
</f></isBlank>
		<filterMatch set="method" line="68" static="1"><f a="s:f">
	<c path="String"/>
	<e path="haxe.xml.Filter"/>
	<e path="Bool"/>
</f></filterMatch>
		<isNullable set="method" line="82" static="1"><f a="r">
	<e path="haxe.xml.Rule"/>
	<e path="Bool"/>
</f></isNullable>
		<check set="method" line="105" static="1"><f a="x:r">
	<c path="Xml"/>
	<e path="haxe.xml.Rule"/>
	<e path="haxe.xml._Check.CheckResult"/>
</f></check>
		<checkList set="method" line="170" static="1"><f a="it:r">
	<t path="Iterator"><c path="Xml"/></t>
	<e path="haxe.xml.Rule"/>
	<e path="haxe.xml._Check.CheckResult"/>
</f></checkList>
		<makeWhere set="method" line="243" static="1"><f a="path">
	<c path="Array"><c path="Xml"/></c>
	<c path="String"/>
</f></makeWhere>
		<makeString set="method" line="258" static="1"><f a="x">
	<c path="Xml"/>
	<c path="String"/>
</f></makeString>
		<makeRule set="method" line="267" static="1"><f a="r">
	<e path="haxe.xml.Rule"/>
	<c path="String"/>
</f></makeRule>
		<makeError set="method" line="278" static="1"><f a="m:?path">
	<e path="haxe.xml._Check.CheckResult"/>
	<c path="Array"><c path="Xml"/></c>
	<c path="String"/>
</f></makeError>
		<checkNode public="1" set="method" line="308" static="1"><f a="x:r">
	<c path="Xml"/>
	<e path="haxe.xml.Rule"/>
	<e path="Void"/>
</f></checkNode>
		<checkDocument public="1" set="method" line="315" static="1"><f a="x:r">
	<c path="Xml"/>
	<e path="haxe.xml.Rule"/>
	<e path="Void"/>
</f></checkDocument>
	</class>
	<class path="Math" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="Hash" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/Hash.hx">
		<__Internal><d/></__Internal>
		<set public="1" set="method" line="33">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="37">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="41">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="45">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="61">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="76">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="sys.db.Manager" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Manager.hx">
		<cnx public="1" set="setConnection" static="1"><c path="sys.db.Connection"/></cnx>
		<lockMode public="1" static="1"><c path="String"/></lockMode>
		<cache_field get="inline" set="null" line="44" static="1"><c path="String"/></cache_field>
		<object_cache line="46" static="1"><c path="Hash"><c path="sys.db.Object"/></c></object_cache>
		<init_list line="47" static="1"><c path="List"><c path="sys.db.Manager"><d/></c></c></init_list>
		<KEYWORDS line="49" static="1"><c path="Hash"><e path="Bool"/></c></KEYWORDS>
		<setConnection set="method" line="56" static="1"><f a="c">
	<c path="sys.db.Connection"/>
	<c path="sys.db.Connection"/>
</f></setConnection>
		<initialize public="1" set="method" line="434" static="1"><f a=""><e path="Void"/></f></initialize>
		<cleanup public="1" set="method" line="442" static="1"><f a=""><e path="Void"/></f></cleanup>
		<quoteAny set="method" line="555" static="1"><f a="v">
	<d/>
	<c path="String"/>
</f></quoteAny>
		<quoteInt public="1" get="inline" set="null" line="561" static="1"><f a="v">
	<c path="Int"/>
	<c path="String"/>
</f></quoteInt>
		<quoteFloat public="1" get="inline" set="null" line="565" static="1"><f a="v">
	<c path="Float"/>
	<c path="String"/>
</f></quoteFloat>
		<quoteDate public="1" get="inline" set="null" line="569" static="1"><f a="v">
	<c path="Date"/>
	<c path="String"/>
</f></quoteDate>
		<quoteString public="1" get="inline" set="null" line="573" static="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></quoteString>
		<quoteBool public="1" get="inline" set="null" line="577" static="1"><f a="v">
	<e path="Bool"/>
	<c path="String"/>
</f></quoteBool>
		<quoteBytes public="1" get="inline" set="null" line="581" static="1"><f a="v">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
</f></quoteBytes>
		<table_infos><t path="sys.db.SpodInfos"/></table_infos>
		<table_name><c path="String"/></table_name>
		<table_fields><c path="List"><c path="String"/></c></table_fields>
		<table_keys><c path="Array"><c path="String"/></c></table_keys>
		<class_proto><a><prototype><d/></prototype></a></class_proto>
		<all public="1" set="method" line="88"><f a="?lock">
	<e path="Bool"/>
	<c path="List"><c path="sys.db.Manager.T"/></c>
</f></all>
		<get public="1" set="method"><f a="id:?lock">
	<d/>
	<e path="Bool"/>
	<c path="sys.db.Manager.T"/>
</f></get>
		<select public="1" set="method"><f a="cond:?options:?lock">
	<d/>
	<d/>
	<e path="Bool"/>
	<c path="sys.db.Manager.T"/>
</f></select>
		<search public="1" set="method"><f a="cond:?options:?lock">
	<d/>
	<d/>
	<e path="Bool"/>
	<c path="List"><c path="sys.db.Manager.T"/></c>
</f></search>
		<count public="1" set="method"><f a="cond">
	<d/>
	<c path="Int"/>
</f></count>
		<delete public="1" set="method"><f a="cond">
	<d/>
	<e path="Void"/>
</f></delete>
		<dynamicSearch public="1" set="method" line="112"><f a="x:?lock">
	<a/>
	<e path="Bool"/>
	<c path="List"><c path="sys.db.Manager.T"/></c>
</f></dynamicSearch>
		<quote set="method" line="121"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<doInsert set="method" line="127"><f a="x">
	<c path="sys.db.Manager.T"/>
	<e path="Void"/>
</f></doInsert>
		<doUpdate set="method" line="181"><f a="x">
	<c path="sys.db.Manager.T"/>
	<e path="Void"/>
</f></doUpdate>
		<doDelete set="method" line="212"><f a="x">
	<c path="sys.db.Manager.T"/>
	<e path="Void"/>
</f></doDelete>
		<doLock set="method" line="222"><f a="i">
	<c path="sys.db.Manager.T"/>
	<e path="Void"/>
</f></doLock>
		<objectToString set="method" line="246"><f a="it">
	<c path="sys.db.Manager.T"/>
	<c path="String"/>
</f></objectToString>
		<cacheObject set="method" line="271"><f a="x:lock">
	<c path="sys.db.Manager.T"/>
	<e path="Bool"/>
	<c path="sys.db.Manager.T"/>
</f></cacheObject>
		<make set="method" line="287"><f a="x">
	<c path="sys.db.Manager.T"/>
	<e path="Void"/>
</f></make>
		<unmake set="method" line="290"><f a="x">
	<c path="sys.db.Manager.T"/>
	<e path="Void"/>
</f></unmake>
		<quoteField set="method" line="293"><f a="f">
	<c path="String"/>
	<c path="String"/>
</f></quoteField>
		<addKeys set="method" line="297"><f a="s:x">
	<c path="StringBuf"/>
	<a/>
	<e path="Void"/>
</f></addKeys>
		<unsafeExecute set="method" line="313"><f a="sql">
	<c path="String"/>
	<c path="sys.db.ResultSet"/>
</f></unsafeExecute>
		<unsafeObject public="1" set="method" line="317"><f a="sql:lock">
	<c path="String"/>
	<e path="Bool"/>
	<c path="sys.db.Manager.T"/>
</f></unsafeObject>
		<unsafeObjects public="1" set="method" line="333"><f a="sql:lock">
	<c path="String"/>
	<e path="Bool"/>
	<c path="List"><c path="sys.db.Manager.T"/></c>
</f></unsafeObjects>
		<unsafeCount public="1" set="method" line="353"><f a="sql">
	<c path="String"/>
	<c path="Int"/>
</f></unsafeCount>
		<unsafeDelete public="1" set="method" line="357"><f a="sql">
	<c path="String"/>
	<e path="Void"/>
</f></unsafeDelete>
		<unsafeGet public="1" set="method" line="361"><f a="id:?lock">
	<d/>
	<e path="Bool"/>
	<c path="sys.db.Manager.T"/>
</f></unsafeGet>
		<unsafeGetWithKeys public="1" set="method" line="380"><f a="keys:?lock">
	<a/>
	<e path="Bool"/>
	<c path="sys.db.Manager.T"/>
</f></unsafeGetWithKeys>
		<addCondition set="method" line="393"><f a="s:x">
	<c path="StringBuf"/>
	<a/>
	<e path="Void"/>
</f></addCondition>
		<dbClass public="1" set="method" line="416"><f a=""><c path="Class"><d/></c></f></dbClass>
		<dbInfos public="1" set="method" line="420"><f a=""><t path="sys.db.SpodInfos"/></f></dbInfos>
		<getCnx set="method" line="424"><f a=""><c path="sys.db.Connection"/></f></getCnx>
		<getLockMode set="method" line="428"><f a=""><c path="String"/></f></getLockMode>
		<initRelation set="method" line="446"><f a="r">
	<t path="sys.db.SpodRelation"/>
	<e path="Void"/>
</f></initRelation>
		<__get set="method" line="483"><f a="x:prop:key:lock">
	<d/>
	<c path="String"/>
	<c path="String"/>
	<t path="Null"><e path="Bool"/></t>
	<c path="sys.db.Manager.T"/>
</f></__get>
		<__set set="method" line="492"><f a="x:prop:key:v">
	<d/>
	<c path="String"/>
	<c path="String"/>
	<c path="sys.db.Manager.T"/>
	<e path="Void"/>
</f></__set>
		<makeCacheKey set="method" line="504"><f a="x">
	<c path="sys.db.Manager.T"/>
	<c path="String"/>
</f></makeCacheKey>
		<addToCache set="method" line="523"><f a="x">
	<c path="sys.db.Manager.T"/>
	<e path="Void"/>
</f></addToCache>
		<removeFromCache set="method" line="527"><f a="x">
	<c path="sys.db.Manager.T"/>
	<e path="Void"/>
</f></removeFromCache>
		<getFromCacheKey set="method" line="531"><f a="key">
	<c path="String"/>
	<c path="sys.db.Manager.T"/>
</f></getFromCacheKey>
		<getFromCache set="method" line="535"><f a="x:lock">
	<c path="sys.db.Manager.T"/>
	<e path="Bool"/>
	<c path="sys.db.Manager.T"/>
</f></getFromCache>
		<new public="1" set="method" line="70"><f a="classval">
	<c path="Class"><c path="sys.db.Manager.T"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	SPOD Manager : the persistent object database manager. See the tutorial on
	haXe website to learn how to use SPOD.
</haxe_doc>
	</class>
	<class path="haxe.xml._Fast.NodeAccess" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="35"><f a="name">
	<c path="String"/>
	<c path="haxe.xml.Fast"/>
</f></resolve>
		<new public="1" set="method" line="31"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.xml.Fast"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.AttribAccess" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="54"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></resolve>
		<new public="1" set="method" line="50"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="String"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasAttribAccess" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="73"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></resolve>
		<new public="1" set="method" line="69"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><e path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasNodeAccess" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="89"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></resolve>
		<new public="1" set="method" line="85"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><e path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.NodeListAccess" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="103"><f a="name">
	<c path="String"/>
	<c path="List"><c path="haxe.xml.Fast"/></c>
</f></resolve>
		<new public="1" set="method" line="99"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="List"><c path="haxe.xml.Fast"/></c></haxe_dynamic>
	</class>
	<class path="haxe.xml.Fast" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Fast.hx">
		<x public="1" set="null"><c path="Xml"/></x>
		<name public="1" get="getName" set="null"><c path="String"/></name>
		<innerData public="1" get="getInnerData" set="null"><c path="String"/></innerData>
		<innerHTML public="1" get="getInnerHTML" set="null"><c path="String"/></innerHTML>
		<node public="1" set="null"><c path="haxe.xml._Fast.NodeAccess"/></node>
		<nodes public="1" set="null"><c path="haxe.xml._Fast.NodeListAccess"/></nodes>
		<att public="1" set="null"><c path="haxe.xml._Fast.AttribAccess"/></att>
		<has public="1" set="null"><c path="haxe.xml._Fast.HasAttribAccess"/></has>
		<hasNode public="1" set="null"><c path="haxe.xml._Fast.HasNodeAccess"/></hasNode>
		<elements public="1" get="getElements" set="null"><t path="Iterator"><c path="haxe.xml.Fast"/></t></elements>
		<getName set="method" line="136"><f a=""><c path="String"/></f></getName>
		<getInnerData set="method" line="140"><f a=""><c path="String"/></f></getInnerData>
		<getInnerHTML set="method" line="152"><f a=""><c path="String"/></f></getInnerHTML>
		<getElements set="method" line="159"><f a=""><a>
	<next><f a=""><c path="haxe.xml.Fast"/></f></next>
	<hasNext><f a=""><e path="Bool"/></f></hasNext>
</a></f></getElements>
		<new public="1" set="method" line="125"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Output" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/Output.hx">
		<_float_bytes line="253" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_float_bytes>
		<_double_bytes line="254" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_double_bytes>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<writeByte public="1" set="method" line="37"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="41"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="64"><f a=""><e path="Void"/></f></flush>
		<close public="1" set="method" line="67"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="70"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<write public="1" set="method" line="77"><f a="s">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></write>
		<writeFullBytes public="1" set="method" line="88"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeFullBytes>
		<writeFloat public="1" set="method" line="96"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method" line="108"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeInt8 public="1" set="method" line="120"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeInt16 public="1" set="method" line="126"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeUInt16 public="1" set="method" line="131"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt24 public="1" set="method" line="142"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt24>
		<writeUInt24 public="1" set="method" line="147"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt24>
		<writeInt31 public="1" set="method" line="160"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt30 public="1" set="method" line="177"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt32 public="1" set="method" line="192"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<prepare public="1" set="method" line="212">
			<f a="nbytes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.
	</haxe_doc>
		</prepare>
		<writeInput public="1" set="method" line="215"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeInput>
		<writeString public="1" set="method" line="237"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<haxe_doc>
	An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.
</haxe_doc>
	</class>
	<class path="cpp.io.FileOutput" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close line="64" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<unknown/>
</f></file_close>
		<file_seek line="65" static="1"><f a="::">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="66" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
</f></file_tell>
		<file_flush line="68" static="1"><f a="">
	<t path="cpp.io.FileHandle"/>
	<unknown/>
</f></file_flush>
		<file_write line="69" static="1"><f a=":::">
	<t path="cpp.io.FileHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_write>
		<file_write_char line="70" static="1"><f a=":">
	<t path="cpp.io.FileHandle"/>
	<c path="Int"/>
	<unknown/>
</f></file_write_char>
		<__f><t path="cpp.io.FileHandle"/></__f>
		<writeByte public="1" set="method" line="39" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="43" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="47" override="1"><f a=""><e path="Void"/></f></flush>
		<close public="1" set="method" line="51" override="1"><f a=""><e path="Void"/></f></close>
		<seek public="1" set="method" line="56"><f a="p:pos">
	<c path="Int"/>
	<e path="cpp.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<tell public="1" set="method" line="60"><f a=""><c path="Int"/></f></tell>
		<new public="1" set="method" line="35"><f a="f">
	<t path="cpp.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Use [cpp.io.File.write] to create a [FileOutput]
</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="39" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="50" static="1">
			<f a="o">
				<d/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="56" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="60" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="66" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="70" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="77" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="84" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="90" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="94" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="100" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="106" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="110" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="114" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="118" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="134" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="138" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="142" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="147" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="haxe.Firebug" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Firebug.hx">
		<detect public="1" set="method" line="29" static="1"><f a=""><e path="Bool"/></f></detect>
		<redirectTraces public="1" set="method" line="45" static="1"><f a=""><e path="Void"/></f></redirectTraces>
		<onError public="1" set="method" line="55" static="1"><f a="err:stack">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></onError>
		<trace public="1" set="method" line="65" static="1"><f a="v:?inf">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
	</class>
	<enum path="XmlType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/Xml.hx" module="Xml"/>
	<class path="Xml" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<_parse line="48" static="1"><f a=":">
	<c path="String"/>
	<a>
		<xml><f a="name:att">
	<c path="String"/>
	<unknown/>
	<e path="Void"/>
</f></xml>
		<pcdata><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></pcdata>
		<done><f a=""><e path="Void"/></f></done>
		<doctype><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></doctype>
		<cur><c path="Xml"/></cur>
		<comment><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></comment>
		<cdata><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></cdata>
	</a>
	<unknown/>
</f></_parse>
		<parse public="1" set="method" line="50" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="113" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="122" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="129" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="136" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="143" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" line="150" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" line="157" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<_nodeName><c path="String"/></_nodeName>
		<_nodeValue><c path="String"/></_nodeValue>
		<_attributes><d><c path="String"/></d></_attributes>
		<_children><c path="Array"><d/></c></_children>
		<_parent><c path="Xml"/></_parent>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<getNodeName set="method" line="171"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method" line="177"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue set="method" line="183"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method" line="189"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<getParent set="method" line="196"><f a=""><c path="Xml"/></f></getParent>
		<get public="1" set="method" line="200">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1" set="method" line="206">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1" set="method" line="215">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1" set="method" line="222">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="228">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<iterator public="1" set="method" line="234">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="241">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="274">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method" line="308">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method" line="314">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="325">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="334">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method" line="342">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1" set="method" line="351">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<toStringRec set="method" line="357"><f a="s">
	<c path="StringBuf"/>
	<e path="Void"/>
</f></toStringRec>
		<new set="method" line="45"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<typedef path="cpp.vm.ThreadHandle" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/vm/Thread.hx" module="cpp.vm.Thread"><d/></typedef>
	<class path="cpp.vm.Thread" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/vm/Thread.hx">
		<current public="1" set="method" line="48" static="1">
			<f a=""><c path="cpp.vm.Thread"/></f>
			<haxe_doc>
		Returns the current thread.
	</haxe_doc>
		</current>
		<create public="1" set="method" line="55" static="1">
			<f a="callb">
				<f a=""><e path="Void"/></f>
				<c path="cpp.vm.Thread"/>
			</f>
			<haxe_doc>
		Creates a new thread that will execute the [callb] function, then exit.
	</haxe_doc>
		</create>
		<readMessage public="1" set="method" line="64" static="1">
			<f a="block">
				<e path="Bool"/>
				<d/>
			</f>
			<haxe_doc>
		Reads a message from the thread queue. If [block] is true, the function
		blocks until a message is available. If [block] is false, the function
		returns [null] if no message is available.
	</haxe_doc>
		</readMessage>
		<handle><t path="cpp.vm.ThreadHandle"/></handle>
		<sendMessage public="1" set="method" line="40">
			<f a="msg">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Send a message to the thread queue. This message can be readed by using [readMessage].
	</haxe_doc>
		</sendMessage>
		<__compare set="method" line="68"><f a="t">
	<a><handle set="null"><t path="cpp.vm.ThreadHandle"/></handle></a>
	<unknown/>
</f></__compare>
		<new set="method" line="33"><f a="h">
	<t path="cpp.vm.ThreadHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Timer" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Timer.hx">
		<delay public="1" set="method" line="77" static="1"><f a="f:time_ms">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<measure public="1" params="T" set="method" line="88" static="1"><f a="f:?pos">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<stamp public="1" set="method" line="98" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns a timestamp, in seconds
	</haxe_doc>
		</stamp>
		<id><t path="Null"><c path="Int"/></t></id>
		<stop public="1" set="method" line="52"><f a=""><e path="Void"/></f></stop>
		<run public="1" set="dynamic" line="74"><f a=""><e path="Void"/></f></run>
		<new public="1" set="method" line="37"><f a="time_ms">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.remoting.ExternalConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/ExternalConnection.hx">
		<implements path="haxe.remoting.Connection"/>
		<escapeString get="inline" set="null" line="59" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></escapeString>
		<connections line="96" static="1"><c path="Hash"><c path="haxe.remoting.ExternalConnection"/></c></connections>
		<doCall set="method" line="98" static="1"><f a="name:path:params">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></doCall>
		<__data><a>
	<name><c path="String"/></name>
	<ctx><c path="haxe.remoting.Context"/></ctx>
</a></__data>
		<__path><c path="Array"><c path="String"/></c></__path>
		<resolve public="1" set="method" line="40"><f a="field">
	<c path="String"/>
	<c path="haxe.remoting.Connection"/>
</f></resolve>
		<close public="1" set="method" line="46"><f a=""><e path="Void"/></f></close>
		<call public="1" set="method" line="64"><f a="params">
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<new set="method" line="35"><f a="data:path">
	<a>
		<name><c path="String"/></name>
		<ctx><c path="haxe.remoting.Context"/></ctx>
	</a>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Synchronous communications between Flash and Javascript.
</haxe_doc>
		<haxe_dynamic><c path="haxe.remoting.Connection"/></haxe_dynamic>
	</class>
	<class path="IntHash" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/IntHash.hx">
		<h><d/></h>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="50">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="55">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="60">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.
</haxe_doc>
	</class>
	<class path="sys.db.Mysql" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/Mysql.hx" extern="1"><connect public="1" set="method" static="1"><f a="params">
	<a>
		<user><c path="String"/></user>
		<socket><t path="Null"><c path="String"/></t></socket>
		<port><t path="Null"><c path="Int"/></t></port>
		<pass><c path="String"/></pass>
		<host><c path="String"/></host>
		<database><c path="String"/></database>
	</a>
	<c path="sys.db.Connection"/>
</f></connect></class>
	<enum path="cpp.zip.Flush" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/zip/Flush.hx">
		<SYNC/>
		<NO/>
		<FULL/>
		<FINISH/>
		<BLOCK/>
	</enum>
	<enum path="haxe._Template.TemplateExpr" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Template.hx" private="1" module="haxe.Template">
		<OpVar a="v"><c path="String"/></OpVar>
		<OpStr a="str"><c path="String"/></OpStr>
		<OpMacro a="name:params">
			<c path="String"/>
			<c path="List"><e path="haxe._Template.TemplateExpr"/></c>
		</OpMacro>
		<OpIf a="expr:eif:eelse">
			<f a=""><d/></f>
			<e path="haxe._Template.TemplateExpr"/>
			<e path="haxe._Template.TemplateExpr"/>
		</OpIf>
		<OpForeach a="expr:loop">
			<f a=""><d/></f>
			<e path="haxe._Template.TemplateExpr"/>
		</OpForeach>
		<OpExpr a="expr"><f a=""><d/></f></OpExpr>
		<OpBlock a="l"><c path="List"><e path="haxe._Template.TemplateExpr"/></c></OpBlock>
	</enum>
	<typedef path="haxe._Template.Token" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Template.hx" private="1" module="haxe.Template"><a>
	<s><e path="Bool"/></s>
	<p><c path="String"/></p>
	<l><c path="Array"><c path="String"/></c></l>
</a></typedef>
	<typedef path="haxe._Template.ExprToken" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Template.hx" private="1" module="haxe.Template"><a>
	<s><e path="Bool"/></s>
	<p><c path="String"/></p>
</a></typedef>
	<class path="haxe.Template" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Template.hx">
		<splitter line="50" static="1"><c path="EReg"/></splitter>
		<expr_splitter line="51" static="1"><c path="EReg"/></expr_splitter>
		<expr_trim line="52" static="1"><c path="EReg"/></expr_trim>
		<expr_int line="53" static="1"><c path="EReg"/></expr_int>
		<expr_float line="54" static="1"><c path="EReg"/></expr_float>
		<globals public="1" line="56" static="1"><d/></globals>
		<expr><e path="haxe._Template.TemplateExpr"/></expr>
		<context><d/></context>
		<macros><d/></macros>
		<stack><c path="List"><d/></c></stack>
		<buf><c path="StringBuf"/></buf>
		<execute public="1" set="method" line="71"><f a="context:?macros">
	<d/>
	<d/>
	<c path="String"/>
</f></execute>
		<resolve set="method" line="80"><f a="v">
	<c path="String"/>
	<d/>
</f></resolve>
		<parseTokens set="method" line="91"><f a="data">
	<c path="String"/>
	<c path="List"><t path="haxe._Template.Token"/></c>
</f></parseTokens>
		<parseBlock set="method" line="127"><f a="tokens">
	<c path="List"><t path="haxe._Template.Token"/></c>
	<e path="haxe._Template.TemplateExpr"/>
</f></parseBlock>
		<parse set="method" line="142"><f a="tokens">
	<c path="List"><t path="haxe._Template.Token"/></c>
	<e path="haxe._Template.TemplateExpr"/>
</f></parse>
		<parseExpr set="method" line="192"><f a="data">
	<c path="String"/>
	<f a=""><unknown/></f>
</f></parseExpr>
		<makeConst set="method" line="223"><f a="v">
	<c path="String"/>
	<f a=""><d/></f>
</f></makeConst>
		<makePath set="method" line="242"><f a="e:l">
	<f a=""><d/></f>
	<c path="List"><t path="haxe._Template.ExprToken"/></c>
	<f a=""><d/></f>
</f></makePath>
		<makeExpr set="method" line="256"><f a="l">
	<c path="List"><t path="haxe._Template.ExprToken"/></c>
	<f a=""><d/></f>
</f></makeExpr>
		<makeExpr2 set="method" line="260"><f a="l">
	<c path="List"><t path="haxe._Template.ExprToken"/></c>
	<f a=""><d/></f>
</f></makeExpr2>
		<run set="method" line="306"><f a="e">
	<e path="haxe._Template.TemplateExpr"/>
	<e path="Void"/>
</f></run>
		<new public="1" set="method" line="64"><f a="str">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.rtti.Generic" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/Generic.hx" interface="1"><haxe_doc>
	You can implement this interface with a parametrized type. For each type
	parameter used, a duplicate class with be created. This is useful on
	platforms that supports runtime typing (such as flash9).
</haxe_doc></class>
	<class path="haxe.rtti.Infos" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/Infos.hx" interface="1"><haxe_doc>
	This is a magic interface. When a class implements [haxe.rtti.Infos], this class and all its
	subclass will get an additional static field [__rtti] storing the class type informations.
</haxe_doc></class>
	<class path="StringBuf" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="46">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="59">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="75">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="89">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="Array"><d/></c></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="cpp.zip.Compress" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/zip/Compress.hx">
		<run public="1" set="method" line="47" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_deflate_init line="58" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></_deflate_init>
		<_deflate_bound line="59" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
</f></_deflate_bound>
		<_deflate_buffer line="60" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<a>
		<write><c path="Int"/></write>
		<read><c path="Int"/></read>
		<done><e path="Bool"/></done>
	</a>
</f></_deflate_buffer>
		<_deflate_end line="61" static="1"><f a="">
	<d/>
	<unknown/>
</f></_deflate_end>
		<_set_flush_mode line="62" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="35"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<a>
		<write><c path="Int"/></write>
		<read><c path="Int"/></read>
		<done><e path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="39"><f a="f">
	<e path="cpp.zip.Flush"/>
	<e path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="43"><f a=""><e path="Void"/></f></close>
		<new public="1" set="method" line="31"><f a="level">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="sys.db._SpodMacros.SqlFunction" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/SpodMacros.hx" private="1" module="sys.db.SpodMacros"><a>
	<sql><c path="String"/></sql>
	<ret><e path="sys.db.SpodType"/></ret>
	<params><c path="Array"><e path="sys.db.SpodType"/></c></params>
	<name><c path="String"/></name>
</a></typedef>
	<enum path="sys.db._SpodMacros.BuildError" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/SpodMacros.hx" private="1" module="sys.db.SpodMacros"><EExpr a="e"><t path="haxe.macro.Expr"/></EExpr></enum>
	<class path="sys.db.SpodMacros" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/SpodMacros.hx">
		<inst line="46" static="1"><c path="sys.db.SpodMacros"/></inst>
		<simpleString line="47" static="1"><c path="EReg"/></simpleString>
		<getInfos public="1" set="method" line="862" static="1"><f a="t">
	<e path="haxe.macro.Type"/>
	<t path="sys.db.SpodInfos"/>
</f></getInfos>
		<cache><c path="Hash"><t path="sys.db.SpodInfos"/></c></cache>
		<types><c path="Hash"><e path="sys.db.SpodType"/></c></types>
		<isNull><e path="Bool"/></isNull>
		<manager><t path="haxe.macro.Expr"/></manager>
		<current><t path="sys.db.SpodInfos"/></current>
		<functions><c path="Hash"><t path="sys.db._SpodMacros.SqlFunction"/></c></functions>
		<error public="1" set="dynamic" line="80"><f a="msg:pos">
	<c path="String"/>
	<t path="haxe.macro.Position"/>
	<d/>
</f></error>
		<typeof public="1" set="dynamic" line="89"><f a="e">
	<t path="haxe.macro.Expr"/>
	<e path="haxe.macro.Type"/>
</f></typeof>
		<follow public="1" set="dynamic" line="98"><f a="t">
	<e path="haxe.macro.Type"/>
	<e path="haxe.macro.Type"/>
</f></follow>
		<makeInt set="method" line="107"><f a="t">
	<e path="haxe.macro.Type"/>
	<t path="Null"><c path="Int"/></t>
</f></makeInt>
		<makeSpod set="method" line="118"><f a="t">
	<e path="haxe.macro.Type"/>
	<c path="String"/>
</f></makeSpod>
		<makeType set="method" line="136"><f a="t">
	<e path="haxe.macro.Type"/>
	<e path="sys.db.SpodType"/>
</f></makeType>
		<makeIdent set="method" line="189"><f a="e">
	<t path="haxe.macro.Expr"/>
	<c path="String"/>
</f></makeIdent>
		<getSpodInfos set="method" line="200"><f a="c">
	<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
	<t path="sys.db.SpodInfos"/>
</f></getSpodInfos>
		<quoteField set="method" line="333"><f a="f">
	<c path="String"/>
	<c path="String"/>
</f></quoteField>
		<initManager set="method" line="338"><f a="pos">
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></initManager>
		<makeString get="inline" set="null" line="342"><f a="s:pos">
	<c path="String"/>
	<t path="haxe.macro.Position"/>
	<a>
		<pos><t path="haxe.macro.Position"/></pos>
		<expr><e path="haxe.macro.ExprDef"/></expr>
	</a>
</f></makeString>
		<makeOp get="inline" set="null" line="346"><f a="op:e1:e2:pos">
	<c path="String"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Position"/>
	<a>
		<pos><t path="haxe.macro.Position"/></pos>
		<expr><e path="haxe.macro.ExprDef"/></expr>
	</a>
</f></makeOp>
		<sqlAdd get="inline" set="null" line="350"><f a="e1:e2:pos">
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Position"/>
	<a>
		<pos><t path="haxe.macro.Position"/></pos>
		<expr><e path="haxe.macro.ExprDef"/></expr>
	</a>
</f></sqlAdd>
		<sqlAddString get="inline" set="null" line="354"><f a="sql:s">
	<t path="haxe.macro.Expr"/>
	<c path="String"/>
	<a>
		<pos><t path="haxe.macro.Position"/></pos>
		<expr><e path="haxe.macro.ExprDef"/></expr>
	</a>
</f></sqlAddString>
		<sqlQuoteValue set="method" line="358"><f a="v:t">
	<t path="haxe.macro.Expr"/>
	<e path="sys.db.SpodType"/>
	<t path="haxe.macro.Expr"/>
</f></sqlQuoteValue>
		<sqlAddValue get="inline" set="null" line="387"><f a="sql:v:t">
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Expr"/>
	<e path="sys.db.SpodType"/>
	<a>
		<pos><t path="haxe.macro.Position"/></pos>
		<expr><e path="haxe.macro.ExprDef"/></expr>
	</a>
</f></sqlAddValue>
		<unifyClass set="method" line="391"><f a="t">
	<e path="sys.db.SpodType"/>
	<c path="Int"/>
</f></unifyClass>
		<tryUnify set="method" line="404"><f a="t:rt">
	<e path="sys.db.SpodType"/>
	<e path="sys.db.SpodType"/>
	<e path="Bool"/>
</f></tryUnify>
		<typeStr set="method" line="411"><f a="t">
	<e path="sys.db.SpodType"/>
	<c path="String"/>
</f></typeStr>
		<canStringify set="method" line="415"><f a="t">
	<e path="sys.db.SpodType"/>
	<e path="Bool"/>
</f></canStringify>
		<convertType set="method" line="422"><f a="t">
	<e path="sys.db.SpodType"/>
	<e path="haxe.macro.ComplexType"/>
</f></convertType>
		<unify set="method" line="439"><f a="t:rt:pos">
	<e path="sys.db.SpodType"/>
	<e path="sys.db.SpodType"/>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></unify>
		<buildCmp set="method" line="444"><f a="op:e1:e2:pos">
	<c path="String"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Position"/>
	<a>
		<t><e path="sys.db.SpodType"/></t>
		<sql><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></sql>
		<n><e path="Bool"/></n>
	</a>
</f></buildCmp>
		<buildNum set="method" line="453"><f a="op:e1:e2:pos">
	<c path="String"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Position"/>
	<a>
		<t><e path="sys.db.SpodType"/></t>
		<sql><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></sql>
		<n><e path="Bool"/></n>
	</a>
</f></buildNum>
		<buildInt set="method" line="467"><f a="op:e1:e2:pos">
	<c path="String"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Position"/>
	<a>
		<t><e path="sys.db.SpodType"/></t>
		<sql><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></sql>
		<n><e path="Bool"/></n>
	</a>
</f></buildInt>
		<buildEq set="method" line="475"><f a="eq:e1:e2:pos">
	<e path="Bool"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Position"/>
	<a>
		<t><e path="sys.db.SpodType"/></t>
		<sql><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></sql>
		<n><e path="Bool"/></n>
	</a>
</f></buildEq>
		<buildDefault set="method" line="497"><f a="cond">
	<t path="haxe.macro.Expr"/>
	<a>
		<t><e path="sys.db.SpodType"/></t>
		<sql><t path="haxe.macro.Expr"/></sql>
		<n><e path="Bool"/></n>
	</a>
</f></buildDefault>
		<buildCond set="method" line="504"><f a="cond">
	<t path="haxe.macro.Expr"/>
	<a>
		<t><e path="sys.db.SpodType"/></t>
		<sql><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></sql>
		<n><e path="Bool"/></n>
	</a>
</f></buildCond>
		<ensureType set="method" line="696"><f a="e:rt">
	<t path="haxe.macro.Expr"/>
	<e path="sys.db.SpodType"/>
	<t path="haxe.macro.Expr"/>
</f></ensureType>
		<checkKeys set="method" line="712"><f a="econd">
	<t path="haxe.macro.Expr"/>
	<e path="Void"/>
</f></checkKeys>
		<orderField set="method" line="743"><f a="e">
	<a>
		<pos set="null"><t path="haxe.macro.Position"/></pos>
		<expr set="null"><e path="haxe.macro.ExprDef"/></expr>
	</a>
	<c path="String"/>
</f></orderField>
		<concatStrings set="method" line="762"><f a="e">
	<t path="haxe.macro.Expr"/>
	<t path="haxe.macro.Expr"/>
</f></concatStrings>
		<browseStrings set="method" line="775"><f a="inf:e">
	<a>
		<str><c path="String"/></str>
		<e><t path="haxe.macro.Expr"/></e>
	</a>
	<t path="haxe.macro.Expr"/>
	<e path="Void"/>
</f></browseStrings>
		<buildOptions set="method" line="812"><f a="eopt">
	<t path="haxe.macro.Expr"/>
	<a>
		<orderBy><c path="String"/></orderBy>
		<limit><a>
	<pos><t path="haxe.macro.Expr"/></pos>
	<len><t path="haxe.macro.Expr"/></len>
</a></limit>
		<forceIndex><c path="String"/></forceIndex>
	</a>
</f></buildOptions>
		<new set="method" line="56"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="sys.db.SpodType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/SpodInfos.hx" module="sys.db.SpodInfos">
		<DUInt/>
		<DUId/>
		<DTinyText/>
		<DTinyInt/>
		<DText/>
		<DString a="n"><c path="Int"/></DString>
		<DSmallText/>
		<DSmallBinary/>
		<DSingle/>
		<DSerialized/>
		<DNull/>
		<DNekoSerialized/>
		<DLongBinary/>
		<DInterval/>
		<DInt/>
		<DId/>
		<DFloat/>
		<DFlags a="flags"><c path="Array"><c path="String"/></c></DFlags>
		<DEncoded/>
		<DDateTime/>
		<DDate/>
		<DBytes a="n"><c path="Int"/></DBytes>
		<DBool/>
		<DBinary/>
		<DBigInt/>
		<DBigId/>
	</enum>
	<typedef path="sys.db.SpodField" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/SpodInfos.hx" module="sys.db.SpodInfos"><a>
	<t><e path="sys.db.SpodType"/></t>
	<name><c path="String"/></name>
	<isNull><e path="Bool"/></isNull>
</a></typedef>
	<typedef path="sys.db.SpodRelation" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/SpodInfos.hx" module="sys.db.SpodInfos"><a>
	<type><c path="String"/></type>
	<prop><c path="String"/></prop>
	<lock><e path="Bool"/></lock>
	<key><c path="String"/></key>
	<isNull><e path="Bool"/></isNull>
	<cascade><e path="Bool"/></cascade>
</a></typedef>
	<typedef path="sys.db.SpodInfos" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/SpodInfos.hx"><a>
	<relations><c path="Array"><t path="sys.db.SpodRelation"/></c></relations>
	<name><c path="String"/></name>
	<key><c path="Array"><c path="String"/></c></key>
	<indexes><c path="Array"><a>
	<unique><e path="Bool"/></unique>
	<keys><c path="Array"><c path="String"/></c></keys>
</a></c></indexes>
	<hfields><c path="Hash"><t path="sys.db.SpodField"/></c></hfields>
	<fields><c path="Array"><t path="sys.db.SpodField"/></c></fields>
</a></typedef>
	<class path="Lambda" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>
		Creates an [Array] from an [Iterable]
	</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>
		Creates a [List] from an [Iterable]
	</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>
		Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.
	</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>
		Similar to [map], but also pass an index for each item iterated.
	</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.
	</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if at least one element of the iterable is found by using the specific function.
	</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if all elements of the iterable have the specified property defined by [f].
	</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Call the function 'f' on all elements of the [Iterable] 'it'.
	</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>
		Return the list of elements matching the function 'f'
	</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>
		Functional 'fold' using an [Iterable]
	</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Count the number of elements in an [Iterable] having [pred] returning true.
	</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an iterable does not contain any element.
	</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.
	</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>
		Returns a list containing all items of 'a' followed by all items of 'b'
	</haxe_doc>
		</concat>
		<haxe_doc>
	The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.
</haxe_doc>
	</class>
	<class path="haxe.macro.MacroType" params="Const" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/MacroType.hx" extern="1"><haxe_doc><![CDATA[
	This type is meant to be used to generate custom types using a macro.
	For instance by doing MacroType<"my.Class.myMacro(55)">
]]></haxe_doc></class>
	<typedef path="haxe.PosInfos" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<typedef path="haxe.remoting.Socket" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/SocketProtocol.hx" module="haxe.remoting.SocketProtocol"><c path="cpp.net.Socket"/></typedef>
	<class path="haxe.remoting.SocketProtocol" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/SocketProtocol.hx">
		<socket public="1"><t path="haxe.remoting.Socket"/></socket>
		<context public="1"><c path="haxe.remoting.Context"/></context>
		<decodeChar set="method" line="68"><f a="c">
	<c path="Int"/>
	<t path="Null"><c path="Int"/></t>
</f></decodeChar>
		<encodeChar set="method" line="87"><f a="c">
	<c path="Int"/>
	<t path="Null"><c path="Int"/></t>
</f></encodeChar>
		<messageLength public="1" set="method" line="108"><f a="c1:c2">
	<c path="Int"/>
	<c path="Int"/>
	<t path="Null"><c path="Int"/></t>
</f></messageLength>
		<encodeMessageLength public="1" set="method" line="116"><f a="len">
	<c path="Int"/>
	<a>
		<c2><t path="Null"><c path="Int"/></t></c2>
		<c1><t path="Null"><c path="Int"/></t></c1>
	</a>
</f></encodeMessageLength>
		<sendRequest public="1" set="method" line="124"><f a="path:params">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></sendRequest>
		<sendAnswer public="1" set="method" line="132"><f a="answer:?isException">
	<d/>
	<e path="Bool"/>
	<e path="Void"/>
</f></sendAnswer>
		<sendMessage public="1" set="method" line="142"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></sendMessage>
		<decodeData public="1" set="dynamic" line="155"><f a="data">
	<c path="String"/>
	<c path="String"/>
</f></decodeData>
		<isRequest public="1" set="method" line="159"><f a="data">
	<c path="String"/>
	<e path="Bool"/>
</f></isRequest>
		<processRequest public="1" set="method" line="167"><f a="data:?onError">
	<c path="String"/>
	<f a="::">
		<c path="Array"><c path="String"/></c>
		<c path="Array"><d/></c>
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></processRequest>
		<processAnswer public="1" set="method" line="189"><f a="data">
	<c path="String"/>
	<d/>
</f></processAnswer>
		<readMessage public="1" set="method" line="198"><f a=""><c path="String"/></f></readMessage>
		<new public="1" set="method" line="63"><f a="sock:ctx">
	<t path="haxe.remoting.Socket"/>
	<c path="haxe.remoting.Context"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	The haXe Remoting Socket Protocol is composed of serialized string exchanges.
	Each string is prefixed with a 2-chars header encoding the string size (up to 4KB)
	and postfixed with the \0 message delimiting char.
	A request string is composed of the following serialized values :
		- the boolean true for a request
		- an array of strings representing the object+method path
		- an array of parameters
	A response string is composed of the following serialized values :
		- the boolean false for a response
		- a serialized value representing the result
	Exceptions are serialized with [serializeException] so they will be thrown immediatly
	when they are unserialized.
</haxe_doc>
	</class>
	<class path="haxe.remoting.HttpAsyncConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/HttpAsyncConnection.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<urlConnect public="1" set="method" line="76" static="1"><f a="url">
	<c path="String"/>
	<c path="haxe.remoting.HttpAsyncConnection"/>
</f></urlConnect>
		<__data><a>
	<url><c path="String"/></url>
	<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
</a></__data>
		<__path><c path="Array"><c path="String"/></c></__path>
		<resolve public="1" set="method" line="37"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<setErrorHandler public="1" set="method" line="43"><f a="h">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
		<call public="1" set="method" line="47"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></call>
		<new set="method" line="32"><f a="data:path">
	<a>
		<url><c path="String"/></url>
		<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
	</a>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="haxe.rtti.Meta" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/Meta.hx">
		<getType public="1" set="method" line="35" static="1">
			<f a="t">
				<d/>
				<d><c path="Array"><d/></c></d>
			</f>
			<haxe_doc>
		Returns the metadata that were declared for the given type (class or enum)
	</haxe_doc>
		</getType>
		<getStatics public="1" set="method" line="43" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>
		Returns the metadata that were declared for the given class fields or enum constructors
	</haxe_doc>
		</getStatics>
		<getFields public="1" set="method" line="51" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>
		Returns the metadata that were declared for the given class static fields
	</haxe_doc>
		</getFields>
		<haxe_doc>
	An api to access classes and enums metadata at runtime.
</haxe_doc>
	</class>
	<class path="haxe.io.StringInput" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/StringInput.hx">
		<extends path="haxe.io.BytesInput"/>
		<new public="1" set="method" line="29"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.remoting.Proxy" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/Proxy.hx">
		<__cnx><c path="haxe.remoting.Connection"/></__cnx>
		<new set="method" line="36"><f a="c">
	<c path="haxe.remoting.Connection"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	This class is magic. When you extend it with a class C, it will automaticaly
	create a stub class with all public methods forwarding remoting messages over
	the connection.
</haxe_doc>
	</class>
	<class path="Enum" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="haxe.remoting.AsyncDebugConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/AsyncDebugConnection.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<create public="1" set="method" line="79" static="1"><f a="cnx">
	<c path="haxe.remoting.AsyncConnection"/>
	<c path="haxe.remoting.AsyncDebugConnection"/>
</f></create>
		<__path><c path="Array"><c path="String"/></c></__path>
		<__cnx><c path="haxe.remoting.AsyncConnection"/></__cnx>
		<__data><a>
	<onresult><f a="::">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
	<e path="Void"/>
</f></onresult>
	<onerror><f a="::">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
	<e path="Void"/>
</f></onerror>
	<oncall><f a=":">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></oncall>
	<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
</a></__data>
		<resolve public="1" set="method" line="44"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<setErrorHandler public="1" set="method" line="50"><f a="h">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
		<setErrorDebug public="1" set="method" line="54"><f a="h">
	<f a="::">
		<c path="Array"><c path="String"/></c>
		<c path="Array"><d/></c>
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorDebug>
		<setResultDebug public="1" set="method" line="58"><f a="h">
	<f a="::">
		<c path="Array"><c path="String"/></c>
		<c path="Array"><d/></c>
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setResultDebug>
		<setCallDebug public="1" set="method" line="62"><f a="h">
	<f a=":">
		<c path="Array"><c path="String"/></c>
		<c path="Array"><d/></c>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setCallDebug>
		<call public="1" set="method" line="66"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></call>
		<new set="method" line="38"><f a="path:cnx:data">
	<c path="Array"><c path="String"/></c>
	<c path="haxe.remoting.AsyncConnection"/>
	<a>
		<onresult><f a="::">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
	<e path="Void"/>
</f></onresult>
		<onerror><f a="::">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
	<e path="Void"/>
</f></onerror>
		<oncall><f a=":">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></oncall>
		<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
	</a>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.remoting.AsyncDebugConnection"/></haxe_dynamic>
	</class>
	<class path="haxe.io.Unsigned_char__" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/BytesData.hx" module="haxe.io.BytesData" extern="1"/>
	<typedef path="haxe.io.BytesData" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/BytesData.hx"><c path="Array"><c path="haxe.io.Unsigned_char__"/></c></typedef>
	<class path="haxe.Public" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Public.hx" interface="1"><haxe_doc>
	When implementing this interface, all default fields access for the class and
	subclasses becomes [public] instead of [private].
</haxe_doc></class>
	<class path="haxe.macro.Tools" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Tools.hx" extern="1"><haxe_doc>
	Some macro utility methods that can be used on different platforms
</haxe_doc></class>
	<typedef path="cpp.io.FileHandle" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/io/File.hx" module="cpp.io.File"><d/></typedef>
	<enum path="cpp.io.FileSeek" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/io/File.hx" module="cpp.io.File">
		<SeekEnd/>
		<SeekCur/>
		<SeekBegin/>
	</enum>
	<class path="cpp.io.File" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/io/File.hx">
		<getContent public="1" set="method" line="40" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<getBytes public="1" set="method" line="45" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<read public="1" set="method" line="50" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="cpp.io.FileInput"/>
</f></read>
		<write public="1" set="method" line="54" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="cpp.io.FileOutput"/>
</f></write>
		<append public="1" set="method" line="58" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="cpp.io.FileOutput"/>
</f></append>
		<copy public="1" set="method" line="62" static="1"><f a="src:dst">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></copy>
		<stdin public="1" set="method" line="70" static="1"><f a=""><c path="cpp.io.FileInput"/></f></stdin>
		<stdout public="1" set="method" line="74" static="1"><f a=""><c path="cpp.io.FileOutput"/></f></stdout>
		<stderr public="1" set="method" line="78" static="1"><f a=""><c path="cpp.io.FileOutput"/></f></stderr>
		<getChar public="1" set="method" line="82" static="1"><f a="echo">
	<e path="Bool"/>
	<c path="Int"/>
</f></getChar>
		<file_stdin line="86" static="1"><f a=""><t path="cpp.io.FileHandle"/></f></file_stdin>
		<file_stdout line="87" static="1"><f a=""><t path="cpp.io.FileHandle"/></f></file_stdout>
		<file_stderr line="88" static="1"><f a=""><t path="cpp.io.FileHandle"/></f></file_stderr>
		<file_contents line="90" static="1"><f a="">
	<c path="String"/>
	<t path="haxe.io.BytesData"/>
</f></file_contents>
		<file_open line="91" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<t path="cpp.io.FileHandle"/>
</f></file_open>
		<getch line="93" static="1"><f a="">
	<e path="Bool"/>
	<c path="Int"/>
</f></getch>
		<haxe_doc>
	API for reading and writing to files.
</haxe_doc>
	</class>
	<class path="cpp.vm.Tls" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/vm/Tls.hx">
		<sFreeSlot line="29" static="1"><c path="Int"/></sFreeSlot>
		<mTLSID><c path="Int"/></mTLSID>
		<value public="1" get="getValue" set="setValue"><c path="cpp.vm.Tls.T"/></value>
		<getValue set="method" line="37"><f a=""><c path="cpp.vm.Tls.T"/></f></getValue>
		<setValue set="method" line="41"><f a="v">
	<c path="cpp.vm.Tls.T"/>
	<c path="cpp.vm.Tls.T"/>
</f></setValue>
		<new public="1" set="method" line="33"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="DateTools" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/DateTools.hx">
		<__format_get set="method" line="38" static="1"><f a="d:e">
	<c path="Date"/>
	<c path="String"/>
	<c path="String"/>
</f></__format_get>
		<__format set="method" line="91" static="1"><f a="d:f">
	<c path="Date"/>
	<c path="String"/>
	<c path="String"/>
</f></__format>
		<format public="1" set="method" line="116" static="1">
			<f a="d:f">
				<c path="Date"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Format the date [d] according to the format [f]. The format
		is compatible with the [strftime] standard format, except that there
		is no support in Flash and JS for day and months names (due to lack
		of proper internationalization API). On haXe/Neko/Windows, some
		formats are not supported.
	</haxe_doc>
		</format>
		<delta public="1" set="method" line="129" static="1">
			<f a="d:t">
				<c path="Date"/>
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date which time has been changed by [t] milliseconds.
	</haxe_doc>
		</delta>
		<DAYS_OF_MONTH line="133" static="1"><c path="Array"><c path="Int"/></c></DAYS_OF_MONTH>
		<getMonthDays public="1" set="method" line="138" static="1">
			<f a="d">
				<c path="Date"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the number of days in a month
	</haxe_doc>
		</getMonthDays>
		<seconds public="1" set="method" line="152" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of seconds to a date-time
	</haxe_doc>
		</seconds>
		<minutes public="1" set="method" line="159" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of minutes to a date-time
	</haxe_doc>
		</minutes>
		<hours public="1" set="method" line="166" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of hours to a date-time
	</haxe_doc>
		</hours>
		<days public="1" set="method" line="173" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of days to a date-time
	</haxe_doc>
		</days>
		<parse public="1" set="method" line="180" static="1">
			<f a="t">
				<c path="Float"/>
				<a>
					<seconds><c path="Int"/></seconds>
					<ms><c path="Float"/></ms>
					<minutes><c path="Int"/></minutes>
					<hours><c path="Int"/></hours>
					<days><c path="Int"/></days>
				</a>
			</f>
			<haxe_doc>
		Separate a date-time into several components
	</haxe_doc>
		</parse>
		<make public="1" set="method" line="196" static="1">
			<f a="o">
				<a>
					<seconds><c path="Int"/></seconds>
					<ms><c path="Float"/></ms>
					<minutes><c path="Int"/></minutes>
					<hours><c path="Int"/></hours>
					<days><c path="Int"/></days>
				</a>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Build a date-time from several components
	</haxe_doc>
		</make>
		<haxe_doc>
	The DateTools class contains some extra functionalities for [Date]
	manipulation. It's stored in a different class in order to prevent
	the standard [Date] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<class path="haxe.rtti.HtmlEditor" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/HtmlEditor.hx">
		<UID line="30" static="1"><c path="Int"/></UID>
		<id><c path="String"/></id>
		<types><c path="Hash"><e path="haxe.rtti.TypeTree"/></c></types>
		<buf><c path="StringBuf"/></buf>
		<nfields><c path="Int"/></nfields>
		<add public="1" set="method" line="41"><f a="tl">
	<t path="haxe.rtti.TypeRoot"/>
	<e path="Void"/>
</f></add>
		<buildHTML public="1" set="method" line="55"><f a="id:v:t">
	<c path="String"/>
	<d/>
	<e path="haxe.rtti.CType"/>
	<c path="String"/>
</f></buildHTML>
		<open set="method" line="65"><f a="t">
	<c path="String"/>
	<e path="Void"/>
</f></open>
		<close set="method" line="69"><f a="?t">
	<c path="String"/>
	<e path="Void"/>
</f></close>
		<genUID set="method" line="73"><f a=""><c path="String"/></f></genUID>
		<genFieldName set="method" line="77"><f a=""><c path="String"/></f></genFieldName>
		<skipField set="method" line="81"><f a=""><e path="Void"/></f></skipField>
		<attrib set="method" line="85"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></attrib>
		<followTypeDef set="method" line="89"><f a="name:params">
	<c path="String"/>
	<c path="List"><e path="haxe.rtti.CType"/></c>
	<e path="haxe.rtti.CType"/>
</f></followTypeDef>
		<getEnum set="method" line="99"><f a="name">
	<c path="String"/>
	<t path="haxe.rtti.Enumdef"/>
</f></getEnum>
		<buildNullField set="method" line="105"><f a="checked">
	<e path="Bool"/>
	<e path="Void"/>
</f></buildNullField>
		<buildHTMLRec set="method" line="115"><f a="v:t:nullable">
	<d/>
	<e path="haxe.rtti.CType"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></buildHTMLRec>
		<buildObject public="1" set="method" line="232"><f a="id:params:t">
	<c path="String"/>
	<c path="Hash"><c path="String"/></c>
	<e path="haxe.rtti.CType"/>
	<d/>
</f></buildObject>
		<buildObjectRec set="method" line="238"><f a="params:t:nullable">
	<c path="Hash"><c path="String"/></c>
	<e path="haxe.rtti.CType"/>
	<e path="Bool"/>
	<d/>
</f></buildObjectRec>
		<skipObjectRec set="method" line="307"><f a="t:nullable">
	<e path="haxe.rtti.CType"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></skipObjectRec>
		<new public="1" set="method" line="37"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="cpp.Int32" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/CppInt32__.hx" module="cpp.CppInt32__"><c path="cpp.CppInt32__"/></typedef>
	<class path="cpp.CppInt32__" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/CppInt32__.hx" extern="1">
		<make public="1" set="method" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<t path="cpp.Int32"/>
</f></make>
		<ofInt public="1" set="method" static="1"><f a="x">
	<c path="Int"/>
	<t path="cpp.Int32"/>
</f></ofInt>
		<toInt public="1" set="method" static="1"><f a="x">
	<t path="cpp.Int32"/>
	<c path="Int"/>
</f></toInt>
		<add public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></add>
		<sub public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></sub>
		<mul public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></mul>
		<div public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></div>
		<mod public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></mod>
		<shl public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<c path="Int"/>
	<t path="cpp.Int32"/>
</f></shl>
		<shr public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<c path="Int"/>
	<t path="cpp.Int32"/>
</f></shr>
		<ushr public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<c path="Int"/>
	<t path="cpp.Int32"/>
</f></ushr>
		<and public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></and>
		<or public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></or>
		<xor public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></xor>
		<neg public="1" set="method" static="1"><f a="a">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></neg>
		<complement public="1" set="method" static="1"><f a="a">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
</f></complement>
		<compare public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<c path="Int"/>
</f></compare>
		<isNeg public="1" set="method" static="1"><f a="a">
	<t path="cpp.Int32"/>
	<e path="Bool"/>
</f></isNeg>
		<isZero public="1" set="method" static="1"><f a="a">
	<t path="cpp.Int32"/>
	<e path="Bool"/>
</f></isZero>
		<ucompare public="1" set="method" static="1"><f a="a:b">
	<t path="cpp.Int32"/>
	<t path="cpp.Int32"/>
	<c path="Int"/>
</f></ucompare>
	</class>
	<class path="haxe.remoting.AsyncProxy" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/AsyncProxy.hx">
		<__cnx><c path="haxe.remoting.AsyncConnection"/></__cnx>
		<new set="method" line="36"><f a="c">
	<c path="haxe.remoting.AsyncConnection"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	This class is magic. When you extend it with a class C, it will automaticaly
	create a stub class with all public methods forwarding remoting messages over
	the connection.
</haxe_doc>
	</class>
	<class path="Array" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="Std" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/Std.hx">
		<is public="1" set="method" line="27" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="31" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" set="method" line="35" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="39" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="43" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="47" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<class path="haxe.remoting.AsyncAdapter" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/AsyncAdapter.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<create public="1" set="method" line="59" static="1"><f a="cnx">
	<c path="haxe.remoting.Connection"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></create>
		<__cnx><c path="haxe.remoting.Connection"/></__cnx>
		<__error><a><ref><f a="">
	<d/>
	<e path="Void"/>
</f></ref></a></__error>
		<resolve public="1" set="method" line="40"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<setErrorHandler public="1" set="method" line="44"><f a="h">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
		<call public="1" set="method" line="48"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></call>
		<new set="method" line="35"><f a="cnx:error">
	<c path="haxe.remoting.Connection"/>
	<a><ref><f a="">
	<d/>
	<e path="Void"/>
</f></ref></a>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Build an AsyncConnection from a synchronized Connection.
</haxe_doc>
	</class>
	<class path="haxe.xml.Proxy" params="Const:T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/xml/Proxy.hx">
		<__f><f a="">
	<c path="String"/>
	<c path="haxe.xml.Proxy.T"/>
</f></__f>
		<resolve public="1" set="method" line="53"><f a="k">
	<c path="String"/>
	<c path="haxe.xml.Proxy.T"/>
</f></resolve>
		<new public="1" set="method" line="49"><f a="f">
	<f a="">
		<c path="String"/>
		<c path="haxe.xml.Proxy.T"/>
	</f>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
	This proxy can be inherited with an XML file name parameter.
	It will	only allow access to fields which corresponds to an "id" attribute
	value in the XML file :

	[
	class MyXml extends haxe.xml.Proxy<"my.xml",MyStructure> {
	}
	...
	var h = new Hash<MyStructure>();
	// ... fill h with "my.xml" content
	var m = new MyXml(h.get);
	trace(m.myNode.structField);
	// access to "myNode" is only possible
	// if you have an id="myNode" attribute
	// in your XML, and completion works as well
	]
]]></haxe_doc>
	</class>
	<class path="cpp.net.SocketInput" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/net/SocketInput.hx">
		<extends path="haxe.io.Input"/>
		<socket_recv line="72" static="1"><f a=":::">
	<t path="cpp.net.SocketHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></socket_recv>
		<socket_recv_char line="73" static="1"><f a="">
	<t path="cpp.net.SocketHandle"/>
	<c path="Int"/>
</f></socket_recv_char>
		<socket_close line="74" static="1"><f a="">
	<t path="cpp.net.SocketHandle"/>
	<unknown/>
</f></socket_close>
		<__s><t path="cpp.net.SocketHandle"/></__s>
		<readByte public="1" set="method" line="37" override="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="50" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="67" override="1"><f a=""><e path="Void"/></f></close>
		<new public="1" set="method" line="33"><f a="s">
	<t path="cpp.net.SocketHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cpp.rtti.FieldNumericIntegerLookup" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/rtti/FieldNumericIntegerLookup.hx" interface="1"><haxe_doc>
	If you implement this interface, then the backend will generate code that
	allows fast numeric access to fields by integer id.  This should speed up the CFFI.
</haxe_doc></class>
	<class path="haxe.remoting.DelayedConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/DelayedConnection.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<process set="method" line="73" static="1"><f a="d">
	<c path="haxe.remoting.DelayedConnection"/>
	<e path="Void"/>
</f></process>
		<create public="1" set="method" line="89" static="1"><f a=""><c path="haxe.remoting.DelayedConnection"/></f></create>
		<connection public="1" get="getConnection" set="setConnection"><c path="haxe.remoting.AsyncConnection"/></connection>
		<__path><c path="Array"><c path="String"/></c></__path>
		<__data><a>
	<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
	<cnx><c path="haxe.remoting.AsyncConnection"/></cnx>
	<cache><c path="Array"><a>
	<path><c path="Array"><c path="String"/></c></path>
	<params><c path="Array"><d/></c></params>
	<onResult><f a="">
	<d/>
	<e path="Void"/>
</f></onResult>
	<onError><f a="">
	<d/>
	<e path="Void"/>
</f></onError>
</a></c></cache>
</a></__data>
		<setErrorHandler public="1" set="method" line="48"><f a="h">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
		<resolve public="1" set="method" line="52"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<getConnection set="method" line="58"><f a=""><c path="haxe.remoting.AsyncConnection"/></f></getConnection>
		<setConnection set="method" line="62"><f a="cnx">
	<c path="haxe.remoting.AsyncConnection"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></setConnection>
		<call public="1" set="method" line="68"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></call>
		<new set="method" line="43"><f a="data:path">
	<a>
		<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
		<cnx><c path="haxe.remoting.AsyncConnection"/></cnx>
		<cache><c path="Array"><a>
	<path><c path="Array"><c path="String"/></c></path>
	<params><c path="Array"><d/></c></params>
	<onResult><f a="">
	<d/>
	<e path="Void"/>
</f></onResult>
	<onError><f a="">
	<d/>
	<e path="Void"/>
</f></onError>
</a></c></cache>
	</a>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="haxe.Resource" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/haxe/Resource.hx">
		<listNames public="1" set="method" line="30" static="1"><f a=""><c path="Array"><c path="String"/></c></f></listNames>
		<getString public="1" set="method" line="33" static="1"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getString>
		<getBytes public="1" set="method" line="36" static="1"><f a="name">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
	</class>
	<class path="haxe.Md5" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Md5.hx">
		<encode public="1" set="method" line="32" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<bitOR set="method" line="58"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></bitOR>
		<bitXOR set="method" line="64"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></bitXOR>
		<bitAND set="method" line="70"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></bitAND>
		<addme set="method" line="76"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></addme>
		<rhex set="method" line="82"><f a="num">
	<c path="Int"/>
	<c path="String"/>
</f></rhex>
		<str2blks set="method" line="92"><f a="str">
	<c path="String"/>
	<c path="Array"><c path="Int"/></c>
</f></str2blks>
		<rol set="method" line="112"><f a="num:cnt">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></rol>
		<cmn set="method" line="116"><f a="q:a:b:x:s:t">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></cmn>
		<ff set="method" line="120"><f a="a:b:c:d:x:s:t">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></ff>
		<gg set="method" line="124"><f a="a:b:c:d:x:s:t">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></gg>
		<hh set="method" line="128"><f a="a:b:c:d:x:s:t">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></hh>
		<ii set="method" line="132"><f a="a:b:c:d:x:s:t">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></ii>
		<doEncode set="method" line="136"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></doEncode>
		<new set="method" line="55"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Creates a MD5 of a String.
</haxe_doc>
	</class>
	<class path="haxe.remoting.LocalConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/LocalConnection.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<ID line="29" static="1"><c path="Int"/></ID>
		<remotingCall set="method" line="80" static="1"><f a="c:id:path:args">
	<c path="haxe.remoting.LocalConnection"/>
	<c path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></remotingCall>
		<remotingResult set="method" line="95" static="1"><f a="c:id:result">
	<c path="haxe.remoting.LocalConnection"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></remotingResult>
		<__path><c path="Array"><c path="String"/></c></__path>
		<__data><a>
	<target><c path="String"/></target>
	<results><c path="IntHash"><a>
	<result><f a="">
	<d/>
	<e path="Void"/>
</f></result>
	<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
</a></c></results>
	<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
	<ctx><c path="haxe.remoting.Context"/></ctx>
	<cnx><d/></cnx>
</a></__data>
		<resolve public="1" set="method" line="51"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<setErrorHandler public="1" set="method" line="57"><f a="h">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
		<call public="1" set="method" line="61"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></call>
		<close public="1" set="method" line="76"><f a=""><e path="Void"/></f></close>
		<new set="method" line="46"><f a="data:path">
	<a>
		<target><c path="String"/></target>
		<results><c path="IntHash"><a>
	<result><f a="">
	<d/>
	<e path="Void"/>
</f></result>
	<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
</a></c></results>
		<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
		<ctx><c path="haxe.remoting.Context"/></ctx>
		<cnx><d/></cnx>
	</a>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="haxe.remoting.SocketConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/SocketConnection.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<__path><c path="Array"><c path="String"/></c></__path>
		<__data><a>
	<results><c path="List"><a>
	<onResult><f a="">
	<d/>
	<e path="Void"/>
</f></onResult>
	<onError><f a="">
	<d/>
	<e path="Void"/>
</f></onError>
</a></c></results>
	<protocol><c path="haxe.remoting.SocketProtocol"/></protocol>
	<log><f a="::">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
	<e path="Void"/>
</f></log>
	<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
</a></__data>
		<resolve public="1" set="method" line="48"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<call public="1" set="method" line="54"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></call>
		<setErrorHandler public="1" set="method" line="63"><f a="h">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
		<setErrorLogger public="1" set="method" line="67"><f a="h">
	<f a="::">
		<c path="Array"><c path="String"/></c>
		<c path="Array"><d/></c>
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorLogger>
		<setProtocol public="1" set="method" line="71"><f a="p">
	<c path="haxe.remoting.SocketProtocol"/>
	<e path="Void"/>
</f></setProtocol>
		<getProtocol public="1" set="method" line="75"><f a=""><c path="haxe.remoting.SocketProtocol"/></f></getProtocol>
		<close public="1" set="method" line="79"><f a=""><e path="Void"/></f></close>
		<processMessage public="1" set="method" line="83"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></processMessage>
		<new set="method" line="43"><f a="data:path">
	<a>
		<results><c path="List"><a>
	<onResult><f a="">
	<d/>
	<e path="Void"/>
</f></onResult>
	<onError><f a="">
	<d/>
	<e path="Void"/>
</f></onError>
</a></c></results>
		<protocol><c path="haxe.remoting.SocketProtocol"/></protocol>
		<log><f a="::">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><d/></c>
	<d/>
	<e path="Void"/>
</f></log>
		<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
	</a>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<class path="cpp.net.SocketOutput" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/net/SocketOutput.hx">
		<extends path="haxe.io.Output"/>
		<socket_close line="66" static="1"><f a="">
	<t path="cpp.net.SocketHandle"/>
	<unknown/>
</f></socket_close>
		<socket_send_char line="67" static="1"><f a=":">
	<t path="cpp.net.SocketHandle"/>
	<c path="Int"/>
	<unknown/>
</f></socket_send_char>
		<socket_send line="68" static="1"><f a=":::">
	<t path="cpp.net.SocketHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></socket_send>
		<__s><t path="cpp.net.SocketHandle"/></__s>
		<writeByte public="1" set="method" line="37" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="50" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="61" override="1"><f a=""><e path="Void"/></f></close>
		<new public="1" set="method" line="33"><f a="s">
	<t path="cpp.net.SocketHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.TypeResolver" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Unserializer.hx" module="haxe.Unserializer"><a>
	<resolveEnum set="method"><f a="name">
	<c path="String"/>
	<c path="Enum"><d/></c>
</f></resolveEnum>
	<resolveClass set="method"><f a="name">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></resolveClass>
</a></typedef>
	<class path="haxe.Unserializer" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="34" static="1"><t path="haxe.TypeResolver"/></DEFAULT_RESOLVER>
		<BASE64 line="36" static="1"><c path="String"/></BASE64>
		<CODES line="39" static="1"><c path="Array"><c path="Int"/></c></CODES>
		<initCodes set="method" line="41" static="1"><f a=""><c path="Array"><c path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="356" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a single value and return it.
	</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><c path="Int"/></pos>
		<length><c path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="81"><f a="r">
	<t path="haxe.TypeResolver"/>
	<e path="Void"/>
</f></setResolver>
		<getResolver public="1" set="method" line="91"><f a=""><t path="haxe.TypeResolver"/></f></getResolver>
		<get get="inline" set="null" line="95"><f a="p">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<readDigits set="method" line="99"><f a=""><c path="Int"/></f></readDigits>
		<unserializeObject set="method" line="124"><f a="o">
	<a/>
	<e path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="139"><f a="edecl:tag">
	<c path="Enum"><d/></c>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="160"><f a=""><d/></f></unserialize>
		<new public="1" set="method" line="64"><f a="buf">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.macro.Position" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><c path="Int"/></min>
	<max><c path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<enum path="haxe.macro.Constant" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<CType a="s"><c path="String"/></CType>
		<CString a="s"><c path="String"/></CString>
		<CRegexp a="r:opt">
			<c path="String"/>
			<c path="String"/>
		</CRegexp>
		<CInt a="v"><c path="String"/></CInt>
		<CIdent a="s"><c path="String"/></CIdent>
		<CFloat a="f"><c path="String"/></CFloat>
	</enum>
	<enum path="haxe.macro.Binop" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpXor/>
		<OpUShr/>
		<OpSub/>
		<OpShr/>
		<OpShl/>
		<OpOr/>
		<OpNotEq/>
		<OpMult/>
		<OpMod/>
		<OpLte/>
		<OpLt/>
		<OpInterval/>
		<OpGte/>
		<OpGt/>
		<OpEq/>
		<OpDiv/>
		<OpBoolOr/>
		<OpBoolAnd/>
		<OpAssignOp a="op"><e path="haxe.macro.Binop"/></OpAssignOp>
		<OpAssign/>
		<OpAnd/>
		<OpAdd/>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpNot/>
		<OpNegBits/>
		<OpNeg/>
		<OpIncrement/>
		<OpDecrement/>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprRequire" params="T" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<enum path="haxe.macro.ExprDef" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<EWhile a="econd:e:normalWhile">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<e path="Bool"/>
		</EWhile>
		<EVars a="vars"><c path="Array"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></c></EVars>
		<EUntyped a="e"><t path="haxe.macro.Expr"/></EUntyped>
		<EUnop a="op:postFix:e">
			<e path="haxe.macro.Unop"/>
			<e path="Bool"/>
			<t path="haxe.macro.Expr"/>
		</EUnop>
		<EType a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EType>
		<ETry a="e:catches">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c>
		</ETry>
		<EThrow a="e"><t path="haxe.macro.Expr"/></EThrow>
		<ETernary a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</ETernary>
		<ESwitch a="e:cases:edef">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</ESwitch>
		<EReturn a="?e"><t path="haxe.macro.Expr"/></EReturn>
		<EParenthesis a="e"><t path="haxe.macro.Expr"/></EParenthesis>
		<EObjectDecl a="fields"><c path="Array"><a>
	<field><c path="String"/></field>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c></EObjectDecl>
		<ENew a="t:params">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ENew>
		<EIn a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EIn>
		<EIf a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</EIf>
		<EFunction a="name:f">
			<t path="Null"><c path="String"/></t>
			<t path="haxe.macro.Function"/>
		</EFunction>
		<EFor a="it:expr">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EFor>
		<EField a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EField>
		<EDisplayNew a="t"><t path="haxe.macro.TypePath"/></EDisplayNew>
		<EDisplay a="e:isCall">
			<t path="haxe.macro.Expr"/>
			<e path="Bool"/>
		</EDisplay>
		<EContinue/>
		<EConst a="c"><e path="haxe.macro.Constant"/></EConst>
		<ECast a="e:t">
			<t path="haxe.macro.Expr"/>
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
		</ECast>
		<ECall a="e:params">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ECall>
		<EBreak/>
		<EBlock a="exprs"><c path="Array"><t path="haxe.macro.Expr"/></c></EBlock>
		<EBinop a="op:e1:e2">
			<e path="haxe.macro.Binop"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EBinop>
		<EArrayDecl a="values"><c path="Array"><t path="haxe.macro.Expr"/></c></EArrayDecl>
		<EArray a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EArray>
	</enum>
	<enum path="haxe.macro.ComplexType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPath a="p"><t path="haxe.macro.TypePath"/></TPath>
		<TParent a="t"><e path="haxe.macro.ComplexType"/></TParent>
		<TFunction a="args:ret">
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<e path="haxe.macro.ComplexType"/>
		</TFunction>
		<TExtend a="p:fields">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Field"/></c>
		</TExtend>
		<TAnonymous a="fields"><c path="Array"><t path="haxe.macro.Field"/></c></TAnonymous>
	</enum>
	<typedef path="haxe.macro.TypePath" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub><t path="Null"><c path="String"/></t></sub>
	<params><c path="Array"><e path="haxe.macro.TypeParam"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<enum path="haxe.macro.TypeParam" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPType a="t"><e path="haxe.macro.ComplexType"/></TPType>
		<TPExpr a="e"><t path="haxe.macro.Expr"/></TPExpr>
	</enum>
	<typedef path="haxe.macro.Function" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params><c path="Array"><a>
	<name><c path="String"/></name>
	<constraints><c path="Array"><e path="haxe.macro.ComplexType"/></c></constraints>
</a></c></params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value><t path="Null"><t path="haxe.macro.Expr"/></t></value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.Expr"/></c></params>
	<name><c path="String"/></name>
</a></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.Metadata"/></meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc><t path="Null"><c path="String"/></t></doc>
	<access><c path="Array"><e path="haxe.macro.Access"/></c></access>
</a></typedef>
	<enum path="haxe.macro.Access" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<AStatic/>
		<APublic/>
		<APrivate/>
		<AOverride/>
		<AInline/>
		<ADynamic/>
	</enum>
	<enum path="haxe.macro.FieldType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<FVar a="t:?e">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<t path="haxe.macro.Expr"/>
		</FVar>
		<FProp a="get:set:t:?e">
			<c path="String"/>
			<c path="String"/>
			<e path="haxe.macro.ComplexType"/>
			<t path="haxe.macro.Expr"/>
		</FProp>
		<FFun a="f"><t path="haxe.macro.Function"/></FFun>
	</enum>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<name><c path="String"/></name>
	<constraints><c path="Array"><e path="haxe.macro.ComplexType"/></c></constraints>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.Metadata"/></meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern><e path="Bool"/></isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<enum path="haxe.macro.TypeDefKind" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TDStructure/>
		<TDEnum/>
		<TDClass a="?extend:?implement:?isInterface">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.TypePath"/></c>
			<e path="Bool"/>
		</TDClass>
	</enum>
	<class path="haxe.macro.Error" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<message public="1"><c path="String"/></message>
		<pos public="1"><t path="haxe.macro.Position"/></pos>
		<new public="1" set="method" line="203"><f a="m:p">
	<c path="String"/>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	This error can be used to handle or produce compilation errors in macros.
</haxe_doc>
	</class>
	<class path="cpp.io.Path" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/io/Path.hx">
		<withoutExtension public="1" set="method" line="60" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></withoutExtension>
		<withoutDirectory public="1" set="method" line="66" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></withoutDirectory>
		<directory public="1" set="method" line="72" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></directory>
		<extension public="1" set="method" line="79" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></extension>
		<withExtension public="1" set="method" line="86" static="1"><f a="path:ext">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></withExtension>
		<ext public="1"><c path="String"/></ext>
		<dir public="1"><c path="String"/></dir>
		<file public="1"><c path="String"/></file>
		<backslash public="1"><e path="Bool"/></backslash>
		<toString public="1" set="method" line="56"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="34"><f a="path">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cpp.vm.Mutex" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/vm/Mutex.hx">
		<m><d/></m>
		<acquire public="1" set="method" line="33"><f a=""><e path="Void"/></f></acquire>
		<tryAcquire public="1" set="method" line="36"><f a=""><e path="Bool"/></f></tryAcquire>
		<release public="1" set="method" line="39"><f a=""><e path="Void"/></f></release>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.remoting.AMFConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/AMFConnection.hx">
		<implements path="haxe.remoting.AsyncConnection"/>
		<__data><a>
	<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
	<cnx><d/></cnx>
</a></__data>
		<__path><c path="Array"><c path="String"/></c></__path>
		<resolve public="1" set="method" line="46"><f a="name">
	<c path="String"/>
	<c path="haxe.remoting.AsyncConnection"/>
</f></resolve>
		<setErrorHandler public="1" set="method" line="52"><f a="h">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setErrorHandler>
		<close public="1" set="method" line="56"><f a=""><e path="Void"/></f></close>
		<call public="1" set="method" line="60"><f a="params:?onResult">
	<c path="Array"><d/></c>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></call>
		<new set="method" line="41"><f a="data:path">
	<a>
		<error><f a="">
	<d/>
	<e path="Void"/>
</f></error>
		<cnx><d/></cnx>
	</a>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.remoting.AsyncConnection"/></haxe_dynamic>
	</class>
	<typedef path="haxe.rtti.Path" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><c path="String"/></typedef>
	<typedef path="haxe.rtti.Platforms" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><c path="List"><c path="String"/></c></typedef>
	<enum path="haxe.rtti.CType" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx">
		<CUnknown/>
		<CTypedef a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="List"><e path="haxe.rtti.CType"/></c>
		</CTypedef>
		<CFunction a="args:ret">
			<c path="List"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c>
			<e path="haxe.rtti.CType"/>
		</CFunction>
		<CEnum a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="List"><e path="haxe.rtti.CType"/></c>
		</CEnum>
		<CDynamic a="?t"><e path="haxe.rtti.CType"/></CDynamic>
		<CClass a="name:params">
			<t path="haxe.rtti.Path"/>
			<c path="List"><e path="haxe.rtti.CType"/></c>
		</CClass>
		<CAnonymous a="fields"><c path="List"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<name><c path="String"/></name>
</a></c></CAnonymous>
	</enum>
	<typedef path="haxe.rtti.PathParams" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<path><t path="haxe.rtti.Path"/></path>
	<params><c path="List"><e path="haxe.rtti.CType"/></c></params>
</a></typedef>
	<typedef path="haxe.rtti.TypeParams" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><c path="Array"><c path="String"/></c></typedef>
	<enum path="haxe.rtti.Rights" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<RNormal/>
		<RNo/>
		<RMethod/>
		<RInline/>
		<RDynamic/>
		<RCall a="m"><c path="String"/></RCall>
	</enum>
	<typedef path="haxe.rtti.ClassField" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<type><e path="haxe.rtti.CType"/></type>
	<set><e path="haxe.rtti.Rights"/></set>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<params><t path="haxe.rtti.TypeParams"/></params>
	<name><c path="String"/></name>
	<isPublic><e path="Bool"/></isPublic>
	<isOverride><e path="Bool"/></isOverride>
	<get><e path="haxe.rtti.Rights"/></get>
	<doc><c path="String"/></doc>
</a></typedef>
	<typedef path="haxe.rtti.TypeInfos" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<path><t path="haxe.rtti.Path"/></path>
	<params><t path="haxe.rtti.TypeParams"/></params>
	<module><t path="haxe.rtti.Path"/></module>
	<isPrivate><e path="Bool"/></isPrivate>
	<doc><c path="String"/></doc>
</a></typedef>
	<typedef path="haxe.rtti.Classdef" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<tdynamic><t path="Null"><e path="haxe.rtti.CType"/></t></tdynamic>
	<superClass><t path="haxe.rtti.PathParams"/></superClass>
	<statics><c path="List"><t path="haxe.rtti.ClassField"/></c></statics>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<path><t path="haxe.rtti.Path"/></path>
	<params><t path="haxe.rtti.TypeParams"/></params>
	<module><t path="haxe.rtti.Path"/></module>
	<isPrivate><e path="Bool"/></isPrivate>
	<isInterface><e path="Bool"/></isInterface>
	<isExtern><e path="Bool"/></isExtern>
	<interfaces><c path="List"><t path="haxe.rtti.PathParams"/></c></interfaces>
	<fields><c path="List"><t path="haxe.rtti.ClassField"/></c></fields>
	<doc><c path="String"/></doc>
</a></typedef>
	<typedef path="haxe.rtti.EnumField" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<name><c path="String"/></name>
	<doc><c path="String"/></doc>
	<args><t path="Null"><c path="List"><a>
	<t><e path="haxe.rtti.CType"/></t>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c></t></args>
</a></typedef>
	<typedef path="haxe.rtti.Enumdef" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<path><t path="haxe.rtti.Path"/></path>
	<params><t path="haxe.rtti.TypeParams"/></params>
	<module><t path="haxe.rtti.Path"/></module>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<doc><c path="String"/></doc>
	<constructors><c path="List"><t path="haxe.rtti.EnumField"/></c></constructors>
</a></typedef>
	<typedef path="haxe.rtti.Typedef" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><a>
	<types><c path="Hash"><e path="haxe.rtti.CType"/></c></types>
	<type><e path="haxe.rtti.CType"/></type>
	<platforms><t path="haxe.rtti.Platforms"/></platforms>
	<path><t path="haxe.rtti.Path"/></path>
	<params><t path="haxe.rtti.TypeParams"/></params>
	<module><t path="haxe.rtti.Path"/></module>
	<isPrivate><e path="Bool"/></isPrivate>
	<doc><c path="String"/></doc>
</a></typedef>
	<enum path="haxe.rtti.TypeTree" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<TTypedecl a="t"><t path="haxe.rtti.Typedef"/></TTypedecl>
		<TPackage a="name:full:subs">
			<c path="String"/>
			<c path="String"/>
			<c path="Array"><e path="haxe.rtti.TypeTree"/></c>
		</TPackage>
		<TEnumdecl a="e"><t path="haxe.rtti.Enumdef"/></TEnumdecl>
		<TClassdecl a="c"><t path="haxe.rtti.Classdef"/></TClassdecl>
	</enum>
	<typedef path="haxe.rtti.TypeRoot" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType"><c path="Array"><e path="haxe.rtti.TypeTree"/></c></typedef>
	<class path="haxe.rtti.TypeApi" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/rtti/CType.hx" module="haxe.rtti.CType">
		<typeInfos public="1" set="method" line="116" static="1"><f a="t">
	<e path="haxe.rtti.TypeTree"/>
	<t path="haxe.rtti.TypeInfos"/>
</f></typeInfos>
		<isVar public="1" set="method" line="127" static="1"><f a="t">
	<e path="haxe.rtti.CType"/>
	<e path="Bool"/>
</f></isVar>
		<leq params="T" set="method" line="134" static="1"><f a="f:l1:l2">
	<f a=":">
		<c path="leq.T"/>
		<c path="leq.T"/>
		<e path="Bool"/>
	</f>
	<c path="List"><c path="leq.T"/></c>
	<c path="List"><c path="leq.T"/></c>
	<e path="Bool"/>
</f></leq>
		<rightsEq public="1" set="method" line="148" static="1"><f a="r1:r2">
	<e path="haxe.rtti.Rights"/>
	<e path="haxe.rtti.Rights"/>
	<e path="Bool"/>
</f></rightsEq>
		<typeEq public="1" set="method" line="163" static="1"><f a="t1:t2">
	<e path="haxe.rtti.CType"/>
	<e path="haxe.rtti.CType"/>
	<e path="Bool"/>
</f></typeEq>
		<fieldEq public="1" set="method" line="212" static="1"><f a="f1:f2">
	<t path="haxe.rtti.ClassField"/>
	<t path="haxe.rtti.ClassField"/>
	<e path="Bool"/>
</f></fieldEq>
		<constructorEq public="1" set="method" line="232" static="1"><f a="c1:c2">
	<t path="haxe.rtti.EnumField"/>
	<t path="haxe.rtti.EnumField"/>
	<e path="Bool"/>
</f></constructorEq>
	</class>
	<enum path="haxe.io.Error" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="haxe.io.BytesOutput" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<writeByte public="1" set="method" line="44" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="52" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<getBytes public="1" set="method" line="126"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="cpp.net.Host" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/net/Host.hx">
		<localhost public="1" set="method" line="45" static="1"><f a=""><c path="String"/></f></localhost>
		<host_resolve line="53" static="1"><f a="">
	<c path="String"/>
	<c path="haxe.Int32"/>
</f></host_resolve>
		<host_reverse line="54" static="1"><f a="">
	<c path="haxe.Int32"/>
	<c path="String"/>
</f></host_reverse>
		<host_to_string line="55" static="1"><f a="">
	<c path="haxe.Int32"/>
	<c path="String"/>
</f></host_to_string>
		<host_local line="56" static="1"><f a=""><c path="String"/></f></host_local>
		<ip public="1" set="null"><c path="haxe.Int32"/></ip>
		<toString public="1" set="method" line="37"><f a=""><c path="String"/></f></toString>
		<reverse public="1" set="method" line="41"><f a=""><c path="String"/></f></reverse>
		<new public="1" set="method" line="33"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Bytes" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="225" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="253" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="292" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="51"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" set="method" line="65"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" set="method" line="93"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="112"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" set="method" line="148"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method" line="207"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="221"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.unit.TestResult" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/unit/TestResult.hx">
		<m_tests><c path="List"><c path="haxe.unit.TestStatus"/></c></m_tests>
		<success public="1" set="null"><e path="Bool"/></success>
		<add public="1" set="method" line="37"><f a="t">
	<c path="haxe.unit.TestStatus"/>
	<e path="Void"/>
</f></add>
		<toString public="1" set="method" line="43"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="32"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="cpp.vm.Lock" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/vm/Lock.hx">
		<l><d/></l>
		<wait public="1" set="method" line="33"><f a="?timeout">
	<c path="Float"/>
	<e path="Bool"/>
</f></wait>
		<release public="1" set="method" line="36"><f a=""><e path="Void"/></f></release>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.Int32" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/haxe/Int32.hx">
		<make public="1" get="inline" set="null" line="31" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" get="inline" set="null" line="35" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<clamp get="inline" set="null" line="39" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></clamp>
		<toInt public="1" get="inline" set="null" line="47" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<toNativeInt public="1" get="inline" set="null" line="56" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toNativeInt>
		<add public="1" get="inline" set="null" line="60" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" get="inline" set="null" line="64" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" get="inline" set="null" line="68" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" get="inline" set="null" line="72" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" get="inline" set="null" line="76" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" get="inline" set="null" line="80" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" get="inline" set="null" line="84" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" get="inline" set="null" line="88" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" get="inline" set="null" line="92" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" get="inline" set="null" line="96" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" get="inline" set="null" line="100" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" get="inline" set="null" line="104" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<isNeg public="1" get="inline" set="null" line="108" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isNeg>
		<isZero public="1" get="inline" set="null" line="112" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isZero>
		<complement public="1" get="inline" set="null" line="116" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" get="inline" set="null" line="120" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
		<ucompare public="1" set="method" line="131" static="1">
			<f a="a:b">
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Compare two Int32 in unsigned mode.
	</haxe_doc>
		</ucompare>
	</class>
	<class path="haxe.unit.TestCase" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/unit/TestCase.hx">
		<implements path="haxe.Public"/>
		<currentTest public="1"><c path="haxe.unit.TestStatus"/></currentTest>
		<setup public="1" set="method" line="34"><f a=""><e path="Void"/></f></setup>
		<tearDown public="1" set="method" line="37"><f a=""><e path="Void"/></f></tearDown>
		<print public="1" set="method" line="40"><f a="v">
	<d/>
	<e path="Void"/>
</f></print>
		<assertTrue public="1" set="method" line="44"><f a="b:?c">
	<e path="Bool"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertTrue>
		<assertFalse public="1" set="method" line="54"><f a="b:?c">
	<e path="Bool"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertFalse>
		<assertEquals public="1" params="T" set="method" line="64"><f a="expected:actual:?c">
	<c path="assertEquals.T"/>
	<c path="assertEquals.T"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertEquals>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="cpp.Random" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/Random.hx">
		<random_new line="47" static="1"><f a=""><unknown/></f></random_new>
		<random_set_seed line="48" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></random_set_seed>
		<random_int line="49" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
</f></random_int>
		<random_float line="50" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></random_float>
		<r><d/></r>
		<setSeed public="1" set="method" line="35"><f a="s">
	<c path="Int"/>
	<e path="Void"/>
</f></setSeed>
		<int public="1" set="method" line="39"><f a="max">
	<c path="Int"/>
	<c path="Int"/>
</f></int>
		<float public="1" set="method" line="43"><f a=""><c path="Float"/></f></float>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.remoting.FlashJsConnection" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/haxe/remoting/FlashJsConnection.hx"/>
	<class path="Date" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/_std/Date.hx">
		<now public="1" set="method" line="55" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" set="method" line="59" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="65" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<mSeconds><c path="Float"/></mSeconds>
		<getTime public="1" set="method" line="35">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1" set="method" line="39">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method" line="41">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method" line="43">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method" line="45">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method" line="47">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method" line="49">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1" set="method" line="51">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method" line="53">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="31"><f a="year:month:day:hour:min:sec">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="cpp.io._Process.Stdin" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/io/Process.hx" private="1" module="cpp.io.Process">
		<extends path="haxe.io.Output"/>
		<_stdin_write line="55" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></_stdin_write>
		<_stdin_close line="56" static="1"><f a="">
	<d/>
	<unknown/>
</f></_stdin_close>
		<p><d/></p>
		<buf><c path="haxe.io.Bytes"/></buf>
		<close public="1" set="method" line="37" override="1"><f a=""><e path="Void"/></f></close>
		<writeByte public="1" set="method" line="42" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="47" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<new public="1" set="method" line="32"><f a="p">
	<unknown/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cpp.io._Process.Stdout" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/io/Process.hx" private="1" module="cpp.io.Process">
		<extends path="haxe.io.Input"/>
		<_stdout_read line="89" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></_stdout_read>
		<_stderr_read line="90" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></_stderr_read>
		<p><d/></p>
		<out><e path="Bool"/></out>
		<buf><c path="haxe.io.Bytes"/></buf>
		<readByte public="1" set="method" line="72" override="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="78" override="1"><f a="str:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="66"><f a="p:out">
	<unknown/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="cpp.io.Process" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/cpp/io/Process.hx">
		<_run line="120" static="1"><f a=":">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<unknown/>
</f></_run>
		<_exit line="121" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></_exit>
		<_pid line="122" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></_pid>
		<_close line="123" static="1"><f a="">
	<d/>
	<unknown/>
</f></_close>
		<p><d/></p>
		<stdout public="1" set="null"><c path="haxe.io.Input"/></stdout>
		<stderr public="1" set="null"><c path="haxe.io.Input"/></stderr>
		<stdin public="1" set="null"><c path="haxe.io.Output"/></stdin>
		<getPid public="1" set="method" line="108"><f a=""><c path="Int"/></f></getPid>
		<exitCode public="1" set="method" line="112"><f a=""><c path="Int"/></f></exitCode>
		<close public="1" set="method" line="116"><f a=""><e path="Void"/></f></close>
		<new public="1" set="method" line="101"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="StringTools" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/StringTools.hx">
		<urlEncode public="1" set="method" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="253" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.
	</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="270" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="sys.db.TableCreate" params="" file="/Applications/FDT 5.app/Contents/FDT5/haXe/haxe-2.08-osx/std/sys/db/TableCreate.hx">
		<getTypeSQL public="1" set="method" line="30" static="1"><f a="t">
	<e path="sys.db.SpodType"/>
	<c path="String"/>
</f></getTypeSQL>
		<create public="1" set="method" line="56" static="1"><f a="manager:?engine">
	<c path="sys.db.Manager"><d/></c>
	<c path="String"/>
	<e path="Void"/>
</f></create>
	</class>
</haxe>